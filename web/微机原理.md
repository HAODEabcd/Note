---
title: 微机原理
date: 2022-07-28 15:56:23
tags:
  - 微机原理
categories:
  - 微机原理
---

# 微机原理

## 绪论

### 微机发展概况

- **电子计算机**
  - 第一代：1946年 电子管 30吨 176㎡ 5000次/s 18000支电子管 6000个继电器 功率150KW 48万美元 
  - 第二代：1958 晶体管计算机
  - 第三代：1965 `SSI/MSI` 集成电路计算机
  - 第四代：1970 `LSI/VLSI`（微型计算机） 超大规模集成电路
  - 第五代：具有人工智能（推理/判断/决策/学习/联想）
- **微型计算机（第四代）**
  - 第一代：`1971` `Intel` `4004/8008`   `4/8位机`   `10~15us`
  - 第二代：`1973` `8080/Z80/M6800/8085` `8位`     `1~2us`
  - 第三代：`1978` `8086/M68000/80286`   `16位`     `0.5us`
  - 第四代：`1983` `80386/486`           `32位`     `<0.1us`
  - 第五代：`1993` `Pentium/P2/P3/P4`    `32/64位`  `fclk>2Ghz`
  - 第六代：`2006` `酷睿(core)双核/四核/八核......`
- **8086(微型计算机第三代)**
  - `Intel 8086/8088 CPU`
  - `128Kb RAM`
  - `5''360kb或720软驱`
  - `5MB硬盘`
- **80286(微型计算机第三代)**
  - `Intel 80286 CPU`
  - `3.5英寸1.44MB软盘`
  - `270万条指令/s`
  - `集成134000个晶体管`
- **80386/486/Pentium/Pro...(微型计算机第四、五代)**
  - Intel第一枚32位处理器：80386
  - 120万晶体管：486
  - 300多万晶体管1亿条指令/s：`Pentium`
  - 550多万晶体管4.4亿条指令/s：`Pentium Pro`
- **计算机第一定理：摩尔定律**
  - 继承电率的集成度每18个月翻一番，既每18个月芯片能力增长一倍
  - 晶体管的数量每两年增加一倍
- **16位机是32/64位机的区别**
  - 16位机是32/64位机的基础
  - 8086系列向上兼容
  - 16位基础-->32/64位拓展

### 微机应用领域

- 科学计算：数/理/化/天文/气象/工程...
- 信息处理：OA/MIS/图文声像多媒体...
- 自动控制：厂矿企业/军事工业/CIMS
- 智能仪器仪表：单片机(MCU)/DSP/ARM类产品
- 网络通讯：无线，光纤，卫星通讯/Internet...
- 计算机辅助系统：CAD/CAM/CAPP/CAI...
- 人工智能：智能机器人/机器视觉/深度学习
- 各个领域，无处不在

### 微机系统的概念

- 硬件
  - 微型计算机
    - CPU：运算器，控制器，寄存器组
    - 存储器：ROM/RAM
    - I/O接口：并行/串行，简单/可编程...
    - 总线：AB、DB、CB
  - 外部设备
    - I/O设备：键盘，鼠标/CRT，PRN
    - 外存储器：软盘/硬盘/光盘/U盘...
- 软件
  - 系统软件：操作系统/编译/汇编/监控程序...
  - 应用软件：MIS/CAD/CAI/MILL/APP...
  - 程序设计语言：机器/汇编/高级语言
- 计算机的结构
  - 冯·诺依曼结构
  - 五箱结构
    - 输入设备、存储器、输出设备、控制器、运算器
    - ![image-20220721143935477](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211439855.png)

### 总线

- 基本单位
  - 8位(bit)=1字节(b/byte)
  - 2byte=1word
  - 1024byte=1kb
  - 1024kb=1MB
  - 1024MB=1GB
  - 1024GB=1TB

- 总线的类型

  - 内部总线/外部总线
  - 局部总线/系统总线
  - 地址总线（AB）：单向/三态，决定寻址容量
  - 数据总线（DB）：双向/三态，决定传输能力
  - 控制总线（CB）：有入有出
  - ![image-20220721144423692](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211453436.png)

  - 微机总线标准
    - 各模块间的互联标准/传输协议
      - 如：PC总线/ISA/EISA/MCA/PCI等
    - 微机系统模块化：符合总线标准的各种模块（如：显示卡、网卡、多功能卡等）可任意插拔、方便拓展

- 寻址能力
  - 取决于地址总线的根数
- 单片机

![image-20220721150017876](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211500036.png)

### 微型计算机的工作过程

- 微型计算机的工作过程是执行程序的过程
- 计算机程序是一组计算机能识别和执行的指令
- 指令的执行过程
  - 取指令->分析指令->读操作数->执行指令->存放结果

### 编码及数值转换

#### 计算机编码

- 数值编码
  - 二进制码、BCD码
- 字符编码
  - ASCII码（用7位二进制表示）
  - '0'---48
  - 'A'---65
  - 'a'---97
  - 七位ASCII码一共可以表示128位
- 汉字编码
  - `gb2312`：国标编码
- 其他编码
  - Unicode
- 声音信息的编码
  - 复杂的声波有许多具有不同振幅和频率的正弦波组成，那这些正弦波如果数字化以让计算机识别和处理呢？
    - `声音->采样->量化->编码->数字化`

  - 采样以一定的频率进行，以赫兹为单位，叫做采样频率
  - 采样频率越高，对原声音模拟就越精确，声质就越好
- 图像信息的编码
  - 图像有两种不同的编码方式：位图编码与矢量图编码
  - 不同的编码会影响图像的质量，存储空间大小
  - 图像的存储方式最直接的就是点阵的方式，阵列中的点称为像素，像素越高，画质越好
- 控制信息
  - 数据信息：即计算机要加工操作的对象
  - 控制信息：指挥计算机如何操作的指令，又称为机器指令
    - 机器级编码
      - 操作码：规定CPU执行何种指令，如加法指令
      - 地址码：指令操作数从哪里取，送往哪里，下一条指令又在哪里取

    - 汇编级编码
      - 用助记符来表示编码，如用ADD来表示
      - 用符号和符号地址来表示操作数与操作数地址，如AX，BX

    - 高级语言


#### 数值及转换

- 十进制 **D**
  - 使用`0-9`之间的数码组成 "逢10进1"
- 二进制 **B**
  - 使用`0,1`数码"逢2进1"
- 八进制 **O**
  - 使用`0-7`之间的数码组成 "逢8进1"
- 十六进制 **H**
  - 使用`0-9,A-F`之间的数码组成，"逢16进1"
- 基：数值所使用的数码的个数，"几进制基就是几"
- 权：数值每一位所具有的值
  - ![202208221105806](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171028889.png)

- 进制转换：[(22条消息) 进制转换方法总结——摘自百度_final__static的博客-CSDN博客_进制转换方法总结](https://blog.csdn.net/final__static/article/details/89405945)

- **BCD码**
  - 使用四个二进制数表示一个十进制数字，最常用的是8421码
  - BCD码的范围位0001~1001，超过1001即为非法，所以BCD码的计算需要重新编码，以保证数据的正确性
  - 压缩BCD码
    - 一个字节(8位)存放一个两位十进制数，其中高四位存放十位数字，低四位存放个位数字
  - 非压缩BCD码
    - 一个字节可存放一个一位二进制数，其中高字节为0，低字节的低四位存放个位
  - ![202208221105791](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171029418.png)

#### 无符号数及有符号数

##### 无符号数

- 无符号数的表示范围
  - 8位
    - `0000 0000B ~ 1111 1111B`
    - 0~255D
  - 16位
    - `0000 0000 0000 0000B ~ 1111 1111 1111 1111B`
    - 0~65535D
- 二进制无符号数的算术运算
  - 乘法
    - 乘以2如果n为整数且大于0“左移n位，右边补零”
    - 如果n不是整数且大于0“转为十进制再乘,再转回二进制”
  - 除法
    - 如果n为整数右移n位，移出去的为余数
    - 如果n不是整数转为十进制除完，再转回二进制

##### 有符号数

- 最高位为符号位：0正、1负

- 表示方法

  - 原码、反码、补码（计算机中数的表示方法）

- 正数

  - 原码、反码、补码相同
  - (18D)<sub>原码</sub>=(18D)<sub>反码</sub>=`0001 0010B`

- 负数

  - 反码：符号位不变其余位按位取反
  - 补码：在反码的基础上加1
  - 表示范围
    - 8位原码：
      - `1111 1111 ~ 0111 1111B`
      - -127 ~ +127D
      - 其中1000 0000和0000 0000都表示0
    - 8位补码
      - `1000 0000 ~ 0111 1111B`
      - -128 ~ +127D
      - 其中1000 0000表示0

- 有符号数的运算

  - [X]<sub>原</sub>+[Y]<sub>原</sub> = [X]<sub>补</sub>+[Y]<sub>补</sub>

  - [X]<sub>原</sub>-[Y]<sub>原</sub> = [X]<sub>补</sub>+[-Y]<sub>补</sub>

##### 溢出

- 运算结果超出表示范围就会产生溢出
- 无符号数溢出判断
  - 对两个无符号二进制数的加减运算，若最高有效位向更高位有进位或相减由借位则产生溢出
  - 8位：0~255
  - 16位：0~65535
- 有符号数溢出判断
  - 如果次高位向最高位有进位（或借位），而最高位向上无进位（无借位），则结果发生溢出
  - 反过来，如果次高位向最高位无进位（或借位），而最高位向上有进位（或借位），则结果发生溢出
  - **最高位仅为状态 (异或) 次高位进位状态=1，则溢出，=0则无溢出**
  - 单符号位
    - 两正数相加得负数，上溢
    - 两负数相加得正数，下溢
  - 双符号位
    - 11表示负数，00表示整数
    - 01表示上溢，10表示下溢
  - 注意：
    - 溢出只能出现在两个同符号相加或两个异符号相减的情况下
  

### 逻辑电路基础及基本构件组成

#### 基本逻辑电路

- 与门
  - 全真则真，有假则假
  - 符号：`·`、`&`、`^`、`x`
  - 逻辑表达式：A·B
  - ![image-20220917110342488](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171117268.png)

- 或门
  - 有真则真，全假则假
  - 符号：`+`、`v`、`|`
  - 逻辑表达式：A+B
  - ![image-20220917110222572](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171117969.png)
- 非门
  - 取反（0变1，1变0）
  - 符号：<span style="text-decoration:overline">非运算符号</span>
  - 逻辑表达式：Y=<span style="text-decoration:overline">A</span>
  - ![image-20220917110322321](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171118086.png)
- 与非门
  - 与门和或门取反，两个都是0取非为1，两个都是1取非为0，有一个为0则为1
  - 逻辑表达式：Y=<span style="text-decoration:overline">A·B</span>
  - ![image-20220917110534968](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171118159.png)
- 或非门
  - 或门与非门取反，两个都是0取非为1，两个都是1取非为0，有一个为1结果为0
  - 逻辑表达式：Y=<span style="text-decoration:overline">A+B</span>
  - ![image-20220917110835382](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171118509.png)
- 异或门
  - 相同为0，不同为1
  - 逻辑表达式：Y=A⊕B
  - ![image-20220917111318504](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171118264.png)
- 注：
  - A和B叫做信号输入端，Y叫做信
  - 号输出端
  - ▷表方向，○表取反，一般我们默认左输出，右输出，但出现复杂电路时，可根据方向符号来表，一般D表输入，Q表输出

#### 触发器

> 触发器(Trigger,T)是计算机记忆装置的基本单元，也是构成时序电路的基础，在计算机中用触发器来存储数据，一个触发器存储一个二进制数

- ![image-20220917121416749](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171214662.png)

- 触发器的种类

  - ![image-20220917121459799](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171215535.png)
  
  - 触发器都有两个输出端 **Q** 和 <span style="text-decoration:overline">**Q**</span>
  
  - 有两个稳定的逻辑状态，通常将 **Q=1** 和 **<span style="text-decoration:overline">Q</span> =0**称为**1**状态，表示此时存储的数据为`"1"`,而把 **Q=0** 和 **<span style="text-decoration:overline">Q</span> =1** 称为**0**状态，表示存储器存储的数据为`"0"`，若输入不发生变化，触发器处于其中一个状态，且保持下去
  
  - 在输入信号的作用下，触发器可以从一个稳定状态转换到另一个稳定状态，这时触发器中存储的数据发生了变化，从`“1”`变为`"0"`，或者从`"0"`变为`"1"`
  
  - 基本R-S触发器
  
    - | <span style="text-decoration:overline">**R**</span> | <span style="text-decoration:overline">**S**</span> | Q    | 逻辑功能 |
    | --------------------------------------------------- | --------------------------------------------------- | ---- | -------- |
    | 0                                                   | 1                                                   | 0    | 置0      |
    | 1                                                   | 0                                                   | 1    | 置1      |
    | 1                                                   | 1                                                   | 不变 | 保持     |
    | 0                                                   | 0                                                   | 不定 | 不允许   |
  
  - 钟控D型触发器
  
    - | D    | CLK        | Q    | <span style="text-decoration:overline">**Q**</span> |
      | ---- | ---------- | ---- | --------------------------------------------------- |
      | 0    | 时钟上升沿 | 0    | 1                                                   |
      | 1    | 时钟上升沿 | 1    | 0                                                   |
  
    - 为了使整个计算机中的各个部件协调运行，计算机中采用了统一的时钟脉冲，来指挥整个计算机的行动，即cp端的作用


#### 寄存器

> 寄存器(Register)是计算机中一个重要部件，用于暂存数据、指令等。
>
> 它是由触发器和一些控制门组成的，有n个触发器可以组成一个n位寄存器

- 缓冲寄存器(Buffer)
  - 在计算机中，缓冲寄存器用于暂存某个数据或地址，以便在适当的时间节拍和给定的计算步骤将数据输入或输出到其他记忆元件中。根据存放的内容，缓冲寄存器分为数据缓冲寄存器器和地址缓冲寄存器。
  - 作为CPU和内存，外部设备之间信息传送的中转站
  - 补偿CPU和内存，外部设备之间在操作速度上的差别
  - 有些简单的运算器中只有一个累加器，这时数据缓冲寄存器还可兼作操作数寄存器
  - ![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171301722.png)
- 移位寄存器(Shifting Register)
  - 移位寄存器具有数据存储和移位两个功能，在移位脉冲的作用下，能将其中所存储的数据逐位向左或向右移位
  - 具有单向移位功能的移位寄存器称为单向移位寄存器，即可向左移也可向右移的寄存器称为双向移位寄存器
  - ![image-20220917130026609](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171302120.png)
- 计数器(Counter)
  - 计数器是计算机、数字仪表中常用的一种电路。他是由若干个触发器组成的寄存器，当一个计数脉冲到达时，它会按二进制数的规律累计脉冲数，使存储在其中的数字加1。
  - 计数器所能累计计算脉冲的最大数目称为该计数器的模，用字母M来表示
  - 计数器的分类
    - 按计数器的功能：加法计数器、减法计数器和可逆计数器
    - 按进位基数分类：二进制计数器（模位2<sup>r</sup>的计数器，r为正数），十进制计数器和任意进制计数器
    - 按进位方式分类：同步计数器（又称为并行计数器）和异步计数器（又称为串行计数器）
    - 其他：方波计数器、环形计数器、程序计数器
- 累加器(Accumulator)
  - 累加器是一个由多个触发器组成的多位寄存器，用于暂存每次在ALU中计算的中间结果。它在微型计算机的数据处理中担负着重要的任务。通常，累加器除了能输入及输出数据外，还能完成移位等操作。

#### 存储器

> 存储器(Memory)由多个寄存器构成，可看作一个寄存器组。每个存储单元均可用来存放数据、地址或者运算程序，每个存储单元所存储的内容为一个字节。
>
> 一个存储器可以包含数以千计的存储单元，为了方便存入和取出，每一个存储单元都必须有一个固定的地址，当然地址也是数以千计的。

- 存储器分类
  - 只读存储器(ROM，Read Only Memory)
    - 用于存放固定程序的存储器，一旦程序存放进入之后即不可改变。不能写入新的字节，只能从中读出所存储的内容。机器断电后，信息并不丢失。
    - 所以，这种存储器主要用来存放监控程序和基本输入/输出程序，还可用来存放各种常用数据和表格等。
  - 随机读写存储器(RAM，Rndom Access Memory)
    - 该存储器不但能读取已存放的数据，还可以随时写入新的数据或改写原来的数据。当机器断电后，所存信息消失。
  - RAM分类
    - 静态RAM：只要有电源加于触发器，数据即可长期保留。(SRAM)
    - 动态RAM：需要刷新，为此还要配置刷新电源。（DRAM）
    - 高速缓冲处理器(cache)
      - 虽然CPU的处理速度很快，但主存储器的存取时间却比CPU慢了一个数量级，所以我们在CPU和主存储器之间加了一个容量较小的高速缓冲处理器，来提高存取速度。
      - ![image-20220917131941653](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171319646.png)
  - ROM的分类
    - ROM：永不更改
    - PROM：可编程的只读存储器，只能写入一次
    - EPROM：紫外线擦除可编程存储器，可多次擦除
    - EEPROM：电可擦可编程存储器，电信号擦除和写入
    - Flash ROM：EEPROM改良，按块擦除

#### 译码器

> 将一个信号、文字或人名等用数字代码表示的过程叫编码。
>
> 反之将数字代码翻译成他们所代表的信号，文字，人名等过程叫译码。完成译码功能的电路或装置叫译码器。

- 二进制译码器输入是一组二进制代码，输出的是一组高低电平信号
- 模拟电路：通过电压幅度不同来传递信息，不同幅度表示不同含义
  - 一旦电压幅度波动，信息含义就发生了改变，容易受到干扰
- 数字电路：通过电压幅度来传递信息，但只有两个状态
  - 一种叫做高电平，即高电压状态，表1，一般规定为5V
  - 一种叫做低电平，即低电平状态，表0，一般规定为0~0.3V
  - ![image-20220917133546286](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171341036.png)
    - 若称”信号输入端(A端)高电平下起作用”，即只有在高电平下才有信号，低电平下无信号，简称高电平有效。
    - 如果不做特别声明，我们均默认输入端为高电平有效，但偶尔也有特别情况。
  - ![image-20220917133625411](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171341197.png)
    - 若称"信号输入端(A端）低电平下起作用”，即只有在低电平下才有信号，高电平下无信号，简称低电平有效。
    - —般来说，当输入端带有非符号时，默认为低电平有效。
- 常见的二进制继承译码器有2-4译码器、3-8译码器、4-6译码器等
  - 3-8译码器(74LS138)
    - ![image-20220917134053440](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171341373.png)
    - G1、G2A、G2B为译码器的3个使能端，它们共同决定了译码器当前是否被允许工作
    - 当G1=1，G2A=G2B=0时，译码器处于使能状态（Enable），否则就被禁止(Disable)

#### 三态电路

> 因为触发器只有零和一两个状态，因此每条数据传输线只能传输零或一。
>
> 如一条数据线既能与一个触发器接通，也能与其断开，而与另一个触发器接通，那么一条数据线就可以传输多个触发器的信息了，三态门因此而被设计。

![image-20220917134349431](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209171344945.png)

- 当E为高电平时，A的两种可能电平(0或1)都可顺利的通到B
- 当E为低电平时，A与B不相通，即存在着高电阻状态/悬浮状态

## 8086系统结构

- 寻址空间
  - 寻址空间指存储器地址允许的最大范围,即CPU能访问多大范围的地址。
  - 由CPU地址总线的位数决定。当存储器按字节编址时,若地址总线为n位，CPU寻址范围是2^n字节。例如，8086CPU有地址总线20位，寻址能力为2^20=1MB。寻址范围的大小和内存的实际容量并不一定相等，如果地址总线位数不够，即使有很大的内存也无法完全访问。

- 8086CPU
  - DB：16条，16位微处理器
  - AB：20条，直接寻址空间，2^20=1MB
  - 时钟频率：5MHz~10MHz
  - 可与8087/8089组成多机系统
  - 40引脚/双列直插/HMOS工艺
- 8088CPU
  - 准16位CPU。DB：内部16位/外部8位
- 8086/8088CPU特点
  - 引脚复用：引脚功能复用/总线分时复用
  - 可控三态结构
  - 单总线，累加器结构

### 8086CPU结构

![image-20220721154150460](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211541664.png)

#### 两大部件

- **总线接口部件BIU**
  - 总线接口单元BIU负责CPU与存储器、1O接口之间的信息传送。
  - 作用：CPU与外部（存储器,I/O）的接口，对外提供16位DB，20位AB
  - 功能：
    - 预取指令序列：BIU会自动进行预取指令操作，并将从存储器中取出的指令按先后次序存入指令缓冲寄存器，以便EU按顺序执行这些指令。
    - 存取数据：在指令执行期间，BIU配合EU，从指定的内存单元或IO端口中取出数据传送给执行单元，或者把执行单元的处理结果传送到指定的内存单元或IO端口中。
    - 将访问主存的逻辑地址转换为实际的物理地址。
  - 组成：
    - 段地址寄存器(16位)：`CS：代码段`、`DS：数据段`、`ES：附加段`、`SS：堆栈段`
    - 指令指针寄存器IP(16位)：存放下一条待执行指令的偏移地址
    - 物理地址加法器：由段地址与偏移地址形成20位物理地址
    - 指令队列寄存器：
      - 预存6字节指令码（先进先出）
      - 可以使EU和BIU同时工作（实现指令的并行执行）
      - 提高了CPU的效率
      - 降低了对存储器存取速度的要求
    - 总线控制逻辑电路：发总线控制信号，存储器、I/O读/写信号
- **指令执行部件EU**
  - 执行部件EU负责进行所有指令的解释和执行，同时管理EU中相关的寄存器
  - 功能：
    - 从指令队列中取出指令代码，由EU控制器进行译码，然后控制各部件完成指令规定的操作
    - 执行指令，并将运算结果的特征状态存放在标志寄存器中
    - 当需要与主存储器或I/O端口传送数据时，EU向BIU发出命令，并提供要访问的内存地址或I/O端口地址及传送的数据
  - 组成：
  
    - ALU(算术逻辑单元)：完成二进制的算数/逻辑运算
    - FLAGS：使用9位，标志分为两类(状态标志位6位，控制标志位3位),存放算术逻辑单元，ALU运算结果的特征，控制标志3位，控制8086的3种特定操作
    - 寄存器组：通用(AX，BX，CX，DX)/专用（SI,DI,SP,BP）
    - EU控制器：从指令流顺序取指令、进行指令译码、完成指令的执行等
  - 8位机执行过程
    - `| 取指 | 执行 | 取指 | 执行 | 取指 | 执行 |` 
  
    - 从外部存储器取指令
  - 8086执行过程
    - `| 取指 | 取指 | 取指 | 取指 | 取指 | 取指 | ` BIU完成
    - `| 等待 | 执行 | 执行 | 执行 | 执行 | 执行 |` EU完成
    - 并行工作
    - 流水线结构：在执行一条指令的同时，又去取另一条指令或若干条指令

#### 寄存器组

![image-20220721174839199](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211748463.png)

- 数据寄存器
  - 数据寄存器用来暂时存放计算过程中所用到的操作数、结果或其他信息，包括累加器AX、基址寄存器BX、计数寄存器CX和数据寄存器DX。这4个寄存器都是16位的，它们都可以以字(16位)或字节(8位)形式访问。
  - **AX**(Accumulator)：主要作为累加器使用，它是算术运算的主要寄存器。另外，所有的IO指令都使用这一寄存器与外部设备传送信息。
  - **BX**(Base)：在计算存储器地址时，他经常用作基址寄存器
  - **CX**(Count)：在循环(Loop)和串处理指令中，用作隐含的寄存器
  - **DX**(Data)：一般在做双字长运算时把DX和AX组合在一起存放一个双字长数，这用来存放高位字。此外，对于某些IO操作，DX可用来存放IO的端口地址。


- 段寄存器（16位）

  - 在8086系统中，存储器是分段管理的，访问存储器的地址码由段地址和段内偏移地址部分组成。段寄存器用来存段地址，包括4个16位寄存器:代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS和附加段寄存器ES。
  - 1MB空间分为若干个逻辑段
  - 存储单元20位实际地址（即：物理地址）由两部分组成：段基址（存放在段寄存器中）和段内偏移地址
  - `物理地址 = 段基址左移4位(乘以16) + 段内偏移地址`
  - **代码段CS**(CodeSegment)：存放当前正在运行的程序所在段的段地址，段内的偏移地址则由IP提供。
  - **数据段DS**(DataSegment)：存放当前程序使用的数据所在段的段地址。
  - **堆栈段SS**(StackSegment)：存放当前堆栈段的段地址。堆栈是在存储器中开辟的、按照“后进先出”的原则组织的一个特殊区域，主要用于子程序调用时保护现场和保存断点
  - **附加段ES**(ExtraSegment)：存放当前程序使用附加段的段地址，附加段是附加的数据段，在执行串操作指令时，作为目的串地址使用
- 地址指针与变址寄存器

  - 地址指针与变址寄存器包括4个16位寄存器:堆栈指针寄存器SP、基址指针寄存器BP、源变址寄存器SI和目的变址寄存器DI。它们一般用来存放主存地址的段内偏移地址。用于形成20位物理地址。另外，它们也可以和数据寄存器一样在运算过程中存放操作数，但只能以字(16位)为单位使用。
  - **堆栈指针寄存器SP**(StackPointer):指出在堆栈段中栈顶的偏移地址。
  - **基址指针寄存器BP**(BasePointer):指出要处理的数据在堆栈段中的起始地址，得注意的是，凡包含BP的寻址方式中，如无特别说明，其段地址由堆栈段寄存器sS也就是说，该寻址方式是对堆栈区的存储单元寻址的。
  - **变址寄存器SI和DI**：在某些间接寻址方式中，用来存放段内偏移量的全部或一部分。在字符串字符串操作指令中SI作源变址寄存器，DI作目标变址寄存器
- 控制寄存器

  - **指令指针IP**（16位）
    - 用来存放下一条将要执行的指令在代码段中的偏移地址，程序员不可以直接使用，但程序控制类指令会用到。它具有自动加1功能，每当执行一次取指令操作，它将自动加1，总是指向下一条要取的指令在现行代码段中的偏移地址。它和CS相结合，形成指向指令存放单元的物理地址。注意每取一个字节后IP内容加1，但取一个字后IP内容加2。
  - **标志寄存器FLAGS**（程序状态字PSW，16位）
    - 存放该处理器的程序状态字。这是一个16位的寄存器，但实际上8086只用到9位，其中6位为状态标志位，3位为控制标志位
    - ![image-20220721172634096](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207211726904.png)
    - 状态标志
      - `CF`：进位标志（反应是否超范围，溢出）
        - 8位无符号数范围：`0~255`
        - 算术运算指令执行后，若运算结果的最高位产生进位或借位，则CF=1;否则CF=O。
      - `AF`：辅助进位标志
        - 算术运算指令执行后，若运算结果的低4位向高4位产生进位或借位，则AF=1;否则AF=O。
      - `SF`：符号标志，结果为负/正
        - 它与运算结果的最高位相同。
        - 若字节运算时D7位为1或字运算时D15位为1，则SF=1;否则SF=0。用补码运算时，它能反映结果的符号特征。
      - `ZF`：零标志
        - 若指令运算结果为0，则ZF=1;否则ZF=0。
      - `PF`：奇偶标志
        - 反映运算结果中1的个数是偶数还是奇数。
        - 运算指令执行后,若运算结果的低8位中含有偶数个1，则PF=1;否则PF=0。
      - `OF`：溢出标志（反应带符号数是否超范围,溢出）
        - 8位带符号数范围：`-128~+127`
        - 16位带符号数范围：`-32768~+32767`
        - 反应有符号数是否超范围
        - 最高位和次高位异或=0的话则代表溢出
        - 当补码运算有溢出时(字节运算时为-128~+127）字运算时为(-32768~+32767)，则OF=1;否则OF=O。
    - 控制标志
      - `DF`：方向标志（地址自动减/增）
        - 用于串操作指令，指定字符串处理时的方向。
        - 设置DF=0时，每执行一次串操作指令，地址指针内容将自动递增;
        - 设置DF=1时，地址指针内容将自动递减。
        - 可用指令设置或清除DF位。(CLD清0，STD置1)
    
      - `IF`：中断标志（中断允许/禁止）
        - 用来控制8086是否允许接收外部中断请求。
        - 设置IF=1时，允许响应可屏蔽中断请求;
        - 设置IF=0时，禁止响应可屏蔽中断请求。
        - 可用指令设置或清除IF位。(CLD清0，STD置1)
        - 注意，IF的状态不影响非屏蔽中断请求(NMI)和CPU内部中断请求。
    
      - `TF`：单步标志（单步允许/禁止）
        - 它是为调试程序而设定的陷阱控制位。
        - 设置TF=1时，使CPU进人单步执行指令工作方式,此时CPU每执行完一条指令就自动产生一次内部中断;当该位复位后，CPU恢复正常工作。
        - 可用指令设置或清除TF位。(CLD清0，STD置1)

### 8086存储器组织

- 8086地址总线20位，寻址能力为1MB，每个字节用唯一的一个地址码标识。地址的范围为0~220—1,用十六进制表示,即00000H~-FFFFFH。这种每个字节对应一个地址的方式称为“按字节编址”

#### 存储器组织

- 存储器地址的分段
  - 8086由20条地址线
    - 寻址空间2^20=1MB（00000H~FFFFFH）
    - 8086有20位地址线,可直接寻址1M存储器物理空间,其地址范围为00000H到FFFFFH与存储单元一一对应的20位地址称为物理地址。
  - CPU内部寄存器16位
    - 不能直接提供20位地址（16位的寄存器无法存储20位的地址信息）
    - *解决办法采用分段技术*
    - 将1M空间分成若干个段，每个逻辑段<=64K，64KB=2<sup>16</sup>，并且规定段起始地址的低4位必须为0，将段地址的高16位称为该段的段地址(或段基地址)，段内存储单元相对于段起始地址偏移量称为当前段内的偏移地址(Offset Address)，由于一个段最大可以包含64KB，这样任何一个内存单元的地址都可以用段地址和偏移地址来表示，每个段的段内地址即可用16位表示
    - 段起始地址应能被16整除，既：地址的最低4位为0
    - ![image-20220722163639278](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629604.png)
- 物理地址
  - 即20位实际地址，又称为绝对地址
  - `物理地址=段基址左移4位(乘以16)+段内偏移地址`
  - ![image-20220920091436707](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209200914616.png)
- 逻辑地址
  - 由两个16位地址构成，**段地址：段内偏移地址**
- 方便重定位
  - 数据块搬家时只需修改段地址
- 一个物理地址可以对应不同的逻辑地址
  - 如：12345H，1200H:0345，1234:0005H，1231：0035
- 每个段的起始地点能被16整除（对于实模式8086）
  - 如：10200H，25010H，12A60H，3F9C0H

#### 存储器分体结构

- 8086系统在实际编程时，一个变量可以是宁节、字或双字类型。

  - `字节数据`(BYTE)：字节数据8位，对应的地址可以是偶地址(地址的最低位AO=0)，也可以是奇地址(A0=1)。当CPU存取字节数据时，只需给出对应的实际地址即可。

  - `字数据`(WORD)：Intel 8086是 16位机，字长 16位，每个字节数据存放在两个连续的字节单元中。其中高8位存放在高地址字节(称为高字节)，低8位存放在低地址字节(称为低字节)，并规定将低字节的地址作为这个字的地址(字地址)，如图2-2所示。若该字地址位于偶地址，即低字节地址为偶数，称为规则字，否则称为非规则字。

  - ![image-20220920085301712](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209200853661.png)

  - `双字数据`(DOUBLE WORD)：双字数据占用4个连续字节单元，并规定最低字节地址为双字的地址。8086系统将1MB的内存分为两个块，每个块的容量都是512KB,其中和数据总线D15～D8相连的块称为高位字节块，它由所有的奇地址单元组成(对应双字数据的 D15~D8，D31~D24位)，也称为奇地址块:和数据总线D7~D0相连的块称为低位字节块，它由所有的偶地址单元组成(对应双字数据的D7~D0，D23~D16位)，也称为偶地址块。

![image-20220920085323624](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209200853554.png)

- 8086 1MB空间分为两个存储体
  - 奇地址存储体：与DB高8位相连
  - 偶地址存储体：与DB低8位相连

![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207240959990.png)

- | BHE  | A0   | 操作                                                         | DB            |
  | ---- | ---- | ------------------------------------------------------------ | ------------- |
  | 0    | 0    | 从偶地址单元开始，在16位地址总线上进行字传送（读/写一个字）  | AD15-0        |
  | 0    | 1    | 从奇地址单元开始，在高8位数据总线上进行字节传送（读/写一个字节） | AD15-8        |
  | 1    | 0    | 从偶地址单元开始，在低8位数据总线上进行字节传送(读/写一个字节) | AD7~0         |
  | 1    | 1    | 无效                                                         |               |
  | 0 1  | 1 0  | 从奇地址起读/写一个字（分两次完成）                          | AD15-8  AD7~0 |

- 对准存放：从偶地址开始存放字数据

- 8088 1MB看出一个整体，不用BHE，A0选择，一次只能一个字节

#### 堆栈的概念

- 堆栈：存储器中开辟的一个区域,存放需暂时保存的数据。
- 存取数据的原则：先进后出/后进先出;一次传送16位/一个字
- 有关寄存器：
  - SS:存放段基址;
  - SP:堆栈指针,始终指向栈顶
- 地址增长方式：向上增长，即:地址由高到低增长
- 堆栈段可在1M空间内任意浮s动
- 堆栈操作:
  - PUSH：压入，SP-2->SP，低8位->(SP)，高8位->(SP+1)
  - POP：弹出,依次弹出低8位、高8位，SP+2->SP

### 8086/8088CPU引脚及功能

> 40引脚，双列直插
>
> 8086采用双列直插式封装，具有40条引脚，使用+5V电源供电。时钟频率有3种:5MHz(8086)，8MHz8086-1)和10MHz(8086-2)。括号内为最大模式时的引脚名称。引脚信号按功能可分为四部分:地址总线、数据总线、控制总线及其他(时钟与电源)。

- 两种工作模式

  - 最小模式：单机系统中所有控制信号，全部由8086直接提供
    - 只有8086一个微处理器工作，所有的总线控制信号都直接有8086产生。
  
  - 最大模式：多处理器系统系统中控制信号由总线控制器8288提供
    - 最大工作模式:包含两个或多个微处理器同时工作，主处理器为8086，其余为协处理器。比如说数值运算是8087，输入输出为8089。
  

#### 40引脚，双列直插

![刻意隐藏的图片](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209141731828.png\)

![image-20220722152717125](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207221527404.png)

![image-20220921090953293](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209210910530.png)

- **公用引脚**

- `AD15~AD0（地址/数据总线）`

  - 分时复用
    - 传送地址时，三态输出，单向
    - 传送数据时，三台输入/输入，双向
  - 总线周期
    - T1：输出访问存储器或I/O的地址信息。--->外部锁存器；
    - T2~T4：输出与存储器和I/O设备交换数据信息（传送数据中断/总线保持响应:高阻）

- `A19/S6~A16/S3（地址/状态线）`

  - 三态，输出，分时复用

  - 分时输出地址的高4位及状态信息

  - 总线周期

    - T1：输出访问存储器的20位地址的高4位地址A19-A16
    - T2~T4：输出CPU状态

  - S6=0：用于指示当前与总线连同；（恒为低电平）

  - S5：反应标志寄存器中中断允许标志IF的当前值（IF为1可响应和屏蔽中断）；

  - S4,S3组合：共有四个组合状态，用以指明当前使用的段寄存器；

    - | S4   | S3   | 当前使用的段寄存器0    |
      | ---- | ---- | ---------------------- |
      | 0    | 0    | ES                     |
      | 0    | 1    | SS                     |
      | 1    | 0    | CS或未使用任何段寄存器 |
      | 1    | 1    | DS                     |

- `BHE/S7（高8位数据总线允许/状态线）`

  - 分时复用，需锁存，三态输出

  - 表示高8位数据线D15~D8上的数据有效和S7状态信号；

  - T1：输出BHE（0/1:高/低8位数据有效）

  - T2-T4：输出S7状态信号。8086无定义

  - 偶地址单元数据通过数据总线低8位传输。

  - 奇地址单元数据通过数据总线高8位传输。

  - | BHE  | A0   | 总线使用情况0                                       |
    | ---- | ---- | --------------------------------------------------- |
    | 0    | 0    | 从偶地址单元开始，在16位数据总线上进行字传送        |
    | 0    | 1    | 从奇地址单元开始，在高8位数据总线上进行进行字节传送 |
    | 1    | 0    | 从偶地址单元开始，在低8位数据总线上进行字节传送     |
    | 1    | 1    | 无效                                                |

- `RD（读选通）`

  - 读信号，三态、输出，低电平有效
  - <span style="text-decoration:overline">RD</span> =0，表明CPU要进行一次内存或IO端口的读操作，具体是对内存还是IO端口进行读操作，决定于M/IO信号。

- `READY（准备就绪信号）`

  - 输入，高电平有效
  - READY=1有效，表示所要访问IO设备或存储器已经准备就绪
  - 若CPU在总线周期T3表示CPU访问的存储器或IO端口已准备好传送数据状态检测到READY=0，则表示未准备好，CPU自动插入一个或多个等待状态T<sub>W</sub>，直到READY=1为止。
  - 保证告诉CPU与低速外设时许的配合

- `TEST（测试信号的输入）`

  - <span style="text-decoration:overline">TEST</span>：测试信号，输入，低电平有效
  - CPU执行WAIT指令时测试TEST，CPU每隔5个T状态进行一次测试
  - 当测试到<span style="text-decoration:overline">TEST</span>=1，则CPU重复执行WAIT指令，即CPU处于空闲等待状态，
  - 直到测试到<span style="text-decoration:overline">TEST</span>=0时，等待状态结束，CPU继续执行后续指令。
  - 可使CPU与外部硬件同步

- `INTR（可屏蔽中断请求信号）`

  - 输入、高电平有效
  - CPU每条指令最后一个T状态测试INTR
  - 如INTR=1，表明外设向CPU发送中断请求，若此时允许中断(IF=1)，则CPU执行完指令最后一个指令周期T后响应中断；如果(IF=0)，CPU不予理睬

- `NMI（非屏蔽中断请求信号）`

  - 输入、上升沿有效
  - 当NMI引脚输入一个由低到高的上升沿时，CPU就会在结束当前执行的指令后，进入非屏蔽中断处理子程序。
  - 该请求信号不受IF状态的影响，也不能用软件屏蔽，一旦该信号有效，则执行完当前指令后立即响应中断
  - 常用于处理最紧急事件

- `RESET（系统复位信号）`

  - 复位信号，输入，高电平有效。
  - RESET信号（>=4T时钟）使CPU复位（CS=0FFFFH，其他寄存器=0）
  - 复位后：标志寄存器、IP、DS、SS、ES为0，CS=0FFFFH**，**复位后CPU从FFFF0H处开始执行**。**

- `MN/MX（最小/最大模式控制信号引脚选择：1/0）`

  - 工作模式控制信号，接+5V电源时，CPU处于最小模式，接地时，CPU处于最大模式
  - MN/<span style="text-decoration:overline">MX</span> =0：表示CPU工作在最大模式系统。
  - MN/<span style="text-decoration:overline">MX</span> =1：表示CPU工作在最小模式系统

- `CLK（时钟信号）`

  - 时钟输入引脚
  - 由8284时钟发生器提供的基本定时脉冲
  - 8086：5~10MHz
  - 要求时钟信号的占空比为33%；
  - 即1/3周期为高电平，2/3周期为低电平

- `Vcc(输入)`

  - 输入、(+5V供电)、电源

- `GND(输入)`

  - 地线，8086CPU有两条接地线

##### 最小模式和引脚

- 最小模式——仅支持单处理器
- 构成的微型机中只包括一个8086处理器，8086的最小模式具有以下几个特点:
  - MN/<span style="text-decoration:overline">MX</span>引脚接+5V电源
  - 使用一片8284，作为时钟信号发生器
  - 使用3片74S373或Intel 8282，作为地址锁存器(总线锁存器)
  - 用两片74LS245或8286/8287作为总线收发器(数据收发器)
  - DT/R作为方向控制
  - DEN作为开门信号
  - 当系统中所连的存储器和外设端口较多时，需要增强数据总线的驱动能力，


![image-20220915103317045](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209210950809.png)

- 最小工作模式引脚信号
  - `INTA（中断响应信号）`
    - 输出
    - 作为INTR的回答信号
    - 当CPU响应INTR时，<span style="text-decoration:overline">INTA</span> =0，表示响应中断。
    - 中断响应时，CPU发出两个INTA负脉冲，第一个通知外设已响应其请求，第二个脉冲外设收到后，向DB放置中断类型号。
  - `ALE（地址锁存允许）`
    - 输出，高电平有效，作9292的选通信号
    - 解决地址/数据复用：T1:ALE=1，在任一总线周期的T1期间输出一个正脉冲，用于输出地址锁存信号到外部锁存器，
    - ALE=1有效，表示地址/数据复用线上的是地址信息，并且有效，利用它的下降沿把地址信息和BHE信号所存在地址锁存其中，ALE不能浮空
  - `DEN（数据允许信号）`
    - 做数据收发器8286的输出允许信号，三态、输出
    - 8286：总线收发器，用于增加总线驱动能力
    - 当DEN=0时有效，最小工作模式下，数据允许读写
  - `DT/R（数据发送/接收控制）信号`
    - 控制8286的数据传输方向，三态，输出
    - 为提高CPU数据总线驱动能力，常常使用数据收发器（8286/8287）；
    - DT/<span style="text-decoration:overline">R</span>控制数据收发器的数据传送方向。
    - DT/<span style="text-decoration:overline">R</span> =0：CPU读，即接收
    - DT/<span style="text-decoration:overline">R</span> =1：CPU写，即发送
  - `WR（写选通）`
    - 写信号、输出、三态，低电平有效
  
    - <span style="text-decoration:overline">WR</span> =0，表示CPU正在执行向存储器或I/O端口的输出操作（与M/IO配合）
  - `M/IO（存储器或I/O端口选择）`
    - 存储器或IO端口访问信号；三态，输出；
    - M/<span style="text-decoration:overline">IO</span> =1时，表示CPU当前正在访问存储器
    - M/<span style="text-decoration:overline">IO</span> =0时，表示CPU当前正在访问I/O端口
    - 控制访问内存还是接口，1访问IO，0访问内存
  
  - | 总线周期 | M/IO | DT/R | RD   | WR   |
    | -------- | ---- | ---- | ---- | ---- |
    | 存储器读 | 1    | 0    | 0    | 1    |
    | 存储器写 | 1    | 1    | 1    | 0    |
    | I/O读    | 0    | 0    | 0    | 1    |
    | I/O写    | 0    | 1    | 0    | 0    |
  
  - `HOLD（总线请求信号）`
    - 输入，高电平有效
    - 此引脚是系统中其他总线主设备向CPU提出总线请求的输入信号。CPU让出总线控制权直到这个信号撤销后才恢复对总线的控制权。
  - `HLDA（总线保持响应）`
    - 输出，高电平有效
    - 表示CPU认可其他总线部件提出的总线占用请求，准备让出总线控制权。
    - HOLD的会打信号。当其他部件发HOLD=1，CPU则发HLDA=1应答，随后让出三总线控制权(高阻)，申请不见随即获得BUS控制权。此后，HOLD=HLDA=1，直至BUS使用完毕，HOLD=0，CPU重获BUS控制权，并使HLDA=0

##### 最大模式和引脚

> 在最大工作模式下，除了8086外，还有输入输出处理器8089及数值数据处理器8087，他们也是分时的方式来占用总线的。
>
> 因此在多处理器系统中必须要用`总线仲裁器8289配合总线控制器8288来确定每一时刻的总线使用权，赋给优先级别较高的处理器使用。`

- 使用一片8284，作为系统时钟。
- 使用三片8282或74LS373，作为地址锁存器。
- 使用两片8286/8287，作为总线收发器
- 使用一片8288，作为总线控制器。
- 使用一片8259，对多个中断源进行中断优先级的管理。

除224~31引脚外，其余与最小模式相同

- `S2，S1，S0（总线周期状态）`

  - 总线周期状态信号,三态、输出

  - 最小模式：CPU直接产生RD，WR，M/IO等各种控制信号

  - 最大模式：这三位组合表示当前周期的操作类型，总线控制器8288接收这3位状态信息，译码产生响应的存储器读/写命令、I/O端口读/写命令及中断响应信号

  - | S2 S1 S0 | 操作                                                         |
    | -------- | ------------------------------------------------------------ |
    | 0 0 0    | 发中断响应信号 <span style="text-decoration:overline">INTA</span> |
    | 0 0 1    | 读I/O口 <span style="text-decoration:overline">IORC</span>   |
    | 0 1 0    | 写I/O口 <span style="text-decoration:overline">IOWC</span> <span style="text-decoration:overline">AIOWC</span> |
    | 0 1 1    | 暂停                                                         |
    | 1 0 0    | 取指令 <span style="text-decoration:overline">MRDC</span>    |
    | 1 0 1    | 读存储器 <span style="text-decoration:overline">MRDC</span>  |
    | 1 1 0    | 写存储器 <span style="text-decoration:overline">MWTC</span> <span style="text-decoration:overline">AMWC</span> |
    | 1 1 1    | 无效                                                         |

- `QS1，QS0（指令队列状态信号）`

  - 用于指示8086内部BIU中指令队列的状态，以便外部协处理器跟踪8086 CPU内部指令序列。

  - | QS1 QS2 | 含义                 |
    | ------- | -------------------- |
    | 0 0     | 无操作               |
    | 0 1     | 从队列中取第一个字节 |
    | 1 0     | 队列已空             |
    | 1 1     | 从队列中取后续字节   |

- `RQ/GT0,RQ/GT1（总线请求/应答信号）`

  - <span style="text-decoration:overline">TO/GT</span><sub>0</sub> <span style="text-decoration:overline">TO/GT</span><sub>1</sub> 

  - 请求/同意信号,双向,低电平有效

  - 输入时表示其它主控者请求使用总线

  - 输出时表示CPU 对总线请求的响应信号

  - 两条线可同时与两个主控者相连。但是GT0的优先级比GT1的高。

  - > 总线访问的请求/允许时序分为3个阶段:
    >
    > 请求、允许和释放。首先是协处理器向8086输出RQ请求使用总线﹐然后在8086 CPU的T4或下一个总线周期的T1期间,CPU输出一个宽度为一个时钟周期的脉冲信台GT给请求总线的协处理器，作为总线响应信号;从下一个时钟周期开始，CPU释放总线。当协处理器使用总线结束时，再给出一个宽度为一个时钟周期的脉冲信号RQ给CPU，表示总线使用结束﹐从下一个时钟周期开始，CPU又控制总线。

- `LOCK（总线封锁信号）`

  - 三态输出，低电平有效
  - <span style="text-decoration:overline">LOCK</span>=0时，代表LOCK有效，CPU禁止其他部件占用总线
  - 若一条指令加上指令前缀LOCK可使指令执行时LOCK=0
  - CPU发送两个INTA之间自动使<span style="text-decoration:overline">LOCK</span>=0
  - 可防止8086在响应中断时总线被其它主控部件所占用，在中断过程中，也自动变为低电平 


#### 8088与8086CPU区别

- 8086：16位机
  - 内部、外部DB宽度均为16位
- 8088：准16位机
  - 内部DB宽度16位，外部8位
  - 8088指令队列长度位4字节
  - 不同引脚定义
    - AD15~8改为A5~8
    - M/IO改为IO/M
    - BHE改为SSO
  - 总线周期状态如表所示

![image-20220722162905559](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207241629201.png)

### CPU时序

- 基本概念
  - 时钟周期
    - 位处理器内部操作的基本时钟单元，宽度为时钟信号相邻两上升沿之间的时钟间隔，也成为一个T周期，由计算机的主频觉得，时钟周期越短，CPU执行的速度就越快
  - 总线周期
    - CPU通过总线对存储器或外设I/O接口进行一次访问所需的时间，包含若干个时钟周期，一个基本的总线周期由4个时钟周期组成，分别称为T1、T2、T3、T4
  - 指令周期
    - 一条指令从开始到最后执行完所需的时间，由若干条总线周期组成

- 系统复位与启动
  - RESET引脚加高电平（>=4T时钟周期），当8086在RESET引脚上检测到一个脉冲的上升沿时，它将停止正在进行的所有操作，处于初始化状态，直到RESET信号变低。因此，通过在CPU的RESET 引脚上加正脉冲，可完成系统的启动和重启动。
  - 如果是初次加电引起的复位，则要求维持不小于50us的高电平
  - 复位后的状态：
    - PSW(FLAGS)、IP、DS、ES、SS全部置零，CS设置为FFFFH
    - 指令队列=0
    - 其他REG=0
      - 由于复位后，IF=0，处关中断状态，所以在初始化程序中应开中断，使CPU可响应中断请求。
  - CPU重启
    - 复位信号RESET从高电平到低电平的跳变会触发CPU内部的复位逻辑电路，当RESET由高电平变低电平7个机器周期后，CPU开始从FFFF0处执行程序。
- 8086读/写总线周期
  - T<sub>1</sub>状态。 
    - M/<span style="text-decoration:overline">IO</span>信号在T状态变为有效。若为高电平，则表明是从存储器读取;若为低电平，则表明是从IO端口读取。并且这个有效电平一直持续到本次总线周期结束﹐即T<sub>4</sub>状态。
    - 同时，CPU在T状态通过A19-A16/S6~S3和AD15一AD0发出访问外设或存储器的20位地址信息﹐并输出<span style="text-decoration:overline">BHE</span>有效信号，表示高8位数据线上的信息可以使用。
    - 总线上的地址信息在T1状态结束之前必须进行锁存，地址锁存器将ALE作为它的锁存允许信号,所以在T1状态,CPU发出一个ALE正脉冲信号,地址锁存器利用ALE的下降沿锁存地址信息。
    - 如果系统中接有数据总线收发器，就要用到DT/R和DEN控制信号，(DEN用)来选通收发器，DTR用来决定收发器的数据传送方向。在T1状态，DT/R变为低电平有效，表明本次总线周期让数据总线收发器接收数据;否则，由数据总线收发器发送数据。

  - T<sub>2</sub>状态
    - 总线上撤销地址信息 A19～A16/S6~S3，引脚输出状态信息S6~S3。AD15～AD0呈高阻状态，为传送数据做准备。
    - 若进行读操作，则CPU在T2状态输出RD氐电平有效信号，否则，进行写操作，CPU在T2状态输<span style="text-decoration:overline">WR</span>低电平有效信号，并立即往数据总线AD15~AD0上发出向外设或存储器写入的数据。
    - DEN信号也在T2状态变为低电平有效状态，选通总线收发器工作。

  - T<sub>3</sub>状态
    - CPU继续提供状态信息，并维持<span style="text-decoration:overline">RD</span>或<span style="text-decoration:overline">RW</span>、M/<span style="text-decoration:overline">IO</span>、DT/<span style="text-decoration:overline">R</span>)及<span style="text-decoration:overline">DEN</span>为有效电平。如果外设或存储器速度较快，则应在T3状态往数据总线AD15~AD0上送入CPU读取的数据信息。

  - T<sub>W</sub>状态
    - 如果所用外设或存储器速度较慢，不能配合CPU的工作，就需要在T3和T4之间插入一个或几个Tw等待状态。系统中的READY电路在Tw状态后生成READY信号，并经8284系统时钟电路同步后加到CPU的READY引脚上,CPU在T3状态开始时采样READY信号，若为低电平，则表明外设或存储器没有准备好，那么，就在T3后插入Tw状态，而且在每个Tw状态的上升沿，CPU都将检测READY信号，直至检测到READY高电平信号后，才结束Tw状态。在最后一个Tw状态中，CPU读取的数据信息已经稳定在数据总线上。

  - T4状态
    - 若为读总线周期，则在T4状态和前一个状态交界的下降沿处，CPU读人已经稳定出现在数据总线上的数据，各控制信号和状态信号变为无效，DEN信号进入高电平，关闭总线收发器8288;若为写周期，则CPU认为外设或存储器已取走了数据，从而撤销数据信息。

  - 读周期
    - ![image-20220921142919067](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209211429371.png)

  - 写周期
    - ![image-20220921142851437](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209211428618.png)

- 在最小模式系统中,如果CPU 以外的其他模块(如 DMA控制器)需要占用总线,就会向CPU提出请求。CPU接收到请求后，如同意让出总线使用权，就会向请求模块发出响应信号，由请求模块占用总线，请求模块使用完总线后再将总线控制权还给CPU，这一过程称为总线保持。8086 CPU为此专门设置了一组控制线(HOLD和HLDA)。
- CPU在每个时钟的上升沿处都会检测HOLD信号。如果检测到高电平，就表明有模块提出总线保持请求，如果此时CPU允许响应，就会在本次总线周期的Ta周期或空闲周期T的下一个时钟周期发出 HLDA 响应信号，并使所有三态输出线都变为高阻状态(包括地址/数据线、地址/状态线及控制线<span style="text-decoration:overline">RD</span>、<span style="text-decoration:overline">WR</span>、<span style="text-decoration:overline">INTA</span>、<span style="text-decoration:overline">M/IO</span>、<span style="text-decoration:overline">DEN</span>、<span style="text-decoration:overline">DT/R</span> 、)，让出总线控制权﹐进入总线保持阶段。直到该模块使用完总线﹐使HOLD恢复低电平状态﹐CPU随之将HLDA也变为低电平，才又收回总线控制权
- ![image-20220921113230730](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209211132218.png)



## 8086指令系统

> 程序是能够完成一个完整任务的一系列有序指令的集合。指令是指示计算机进行某种操作的命令，是用户使用与控制计算机运行的最小功能单位。指令与计算机的硬件结构直接相关，不同的CPU能够执行的指令种类、数量都不同。一台计算机所能执行的全部指令的集合，称为该计算机的指令系统。

- **程序**：指令的有序集合
- **指令**：控制计算机完成某种操作的命令
- **指令系统**：处理器所能识别的所有指令的集合（计算机所能执行的全部指令的集合）
- **机器指令**。指令以二进制编码的形式存放在存储器中，用二进制编码形式表示的指令
- **符号指令**：用符号表示的指令，汇编语言程序中的指令就是符号指令。具有直观、易理解和可帮助记忆的特点。
- 每种CPU都有各自的指令系统
- **指令格式**
  - `标号: 操作码 操作数 ;注释`
  - 标号：给该指令所在的地址取名字，必须以冒号结尾，可缺省，并遵循下列规则:
    - 由字母(大小写均可)数字与特殊字符(@，-，?)组成
    - 第一个字符不能是数字
    - 不能单独作为标识符
    - 有效长度为31个，如果超过，则保留前31个
  - 操作码：参加本指令的运算数据，有双操作数指令，单操作数指令和无操作数指令。。
  - 操作数：参与运算的操作数或存放操作数的地址；（可为立即数，寄存器，存储单元，I/O接口）（单/双/多/无）
  - 例：`MOV AL, 3AH ;AL<-3AH B03A`
    - MOV为操作码,AL为累加寄存器，3AH为操作数，AL<-3AH为注释，B03A为对应的机器码
  - ![image-20220923090858582](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209230909827.png)
- **操作数存在方式**
  - 操作数包含在指令中——即指令的操作数部分就包含着操作数本身。
    - `MOV AX 1234;`

  - 操作数包含在CPU的某一个内部寄存器中——这时指令中的操作数是CPU内部的某一个寄存器
    - `MOV AX, BX;`

  - 操作数在内存的数据区中——这时指令中的操作数包含着此操作数的地址
    - `MOV AX, [2000H];`

  - 操作数在**I**/O端口寄存器中——这时指令中的操作数包含着此操作数的所在端口地址
    - `IN AL, N(端口号)`


### 8086寻址方式

> 程序执行过程中，程序中的指令和数据都存储在内存储器中。程序执行时，处理器首先根据指令地址访问相应的内存单元，取出指令代码，CPU再根据指令代码中的操作数字段，取出操作数，去执行响应的操作。
>
> 形成指令地址或操作数地址的方式，称为寻址方式。
>
> 8086CPU的寻址分为两类，即指令寻址方式和数据寻址方式。

- **立即（立即数）寻址**
  - 操作数直接存放在指令中，紧跟在操作码之后，作为指令的一部分，存放在代码段里，这种操作数称为**立即数**。常用来给寄存器赋值。
  - 源操作数和目的操作数字长必须一致
  - 立即数可以是8位，也可以是16位，且只能是整数，高位与高位对应，低位与低位对应;
  - 立即寻址方式主要用来给寄存器或存储单元赋值，因此不能用于单操作数指令;
  - 在双操作数指令中，立即数也只能用于源操作数，不能用于目标操作数;
  - *优点*:
    - 由于立即寻址方式中操作数直接从指令中取得，因此指令执行速度快。
  - *缺点*:
    - 在立即寻址方式中，操作数是指令的一部分，不能修改，因此，立即寻址方式只能适用于操作数固定的情况，而很多情况下，指令所处理的数据都是在不断变化的，这就需要引入其他寻址方式。


```assembly
MOV AL, 26H    ; 8位立即数
MOV CX, 2A50H  ; 16位
MOV AX, 0FF00H ; 16位
```

- **寄存器寻址**
  - 操作数在CPU内部的通用寄存器中，指令中指定寄存器名(机器指令中为寄存器的二进制编号）
  - 从某一个寄存器中寻找数据，赋给目的操作寄存器
  - 格式：`指令 目的寄存器 源寄存器`
  - 两个操作数不能能为段寄存器
  - 目的操作数不能为代码寄存器
  - *优点*
    - 寄存器数量一般在几个到几十个，因此所需地址码较短﹐从而缩短了指令长度﹐节省了程序存储空间;
    - 从寄存器里取数比从存储器里取数的速度快得多，从而提高了指令执行速度。
  
  - *缺点*
    - 寄存器数量较少
  

```assembly
MOV DX, AX ;（将AX寄存器的数的数送于DX寄存器）
MOV CL, AH ; copy
```

- **存储器寻址**
  - 当操作数存放在内存储器中时，操作数的物理地址可由逻辑地址计算出来，即`物理地址=段地址×10H+段内偏移地址`。
  - 其中段地址由段寄存器给出，而偏移地址则要从指令地址码部分计算求得，这个(偏移地址称为有效地址(Effective Address，EA)
  - 相应地，指令地址码字段给出的地址，称为形式地址或位移量(DISP)
  - 存储器寻址方式，就是通过形式地址计算出操作数有效地址的过程，包括直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址加变址寻址。

- **直接寻址**
  - 操作数在内存中，操作数的有效地址由指令地址码字段直接给出，这种方式称为直接寻址方式。
  - **EA**：操作数的偏移地址
  - **PA**：（DS）×16＋EA（段地址左移4位+段内偏移地址）
  - 直接寻址允许数据存于附加段ES、堆栈段SS、代码段CS，这称为“段跨越或段超越”
  - `MOV AL, [2000H] ;` 默认段为DS，一个数外面有[]就代表是一个偏移地址，从一个地址中寻找数据给AL

```assembly
若DS=3000H，(32000H)=1234H
MOV AX, [2000H] ; AX=1234H，计算得到了3000H*16+2000H=32000H，将32000H中的值赋给AX，而不是32000H这个地址本身

MOV AX, ES:[500H] ; 段超越前缀，操作数地址=ES*16+500H
MOV AX, VALUE ; 符号地址/立即数
```

- **寄存器间接寻址**
  - 当采用寄存器间接寻址方式时，操作数在内存中，操作数的有效地址被放在一个寄存器中，该寄存器由指令地址码字段指定，可以使用基址寄存器BX、BP或委址寄存器SI、DI,
  - 为了区别于寄存器寻址，寄存器名用“［］”括起。
  - 有效地址EA为基址寄存器（BX，BP）的内容加偏移量。EA为BP时，默认段为SS，EA为其他时时默认段则为DS

    - 当EA=(BX)+DISP时，PA=(DS)*16+EA
    - 当EA=(BP)+DISP时，PA=(SS)*16+EA


```assembly
MOV BX, [SI]	;若DS=1000H，SI=2000H，(12000H)=318BH，则执行后BX=318BH，计算方法和直接寻址一样
MOV AX, [BP] 	;如果EA=BP时，默认段为SS，其他都为DS
MOV BX, DS:[BP] ;强制段为DS，EA=DS
MOV AX, ES:[SI] 等同于 ES: MOV AX [SI] ;段超越前缀，EA=ES
```


- **寄存器(间接)相对寻址**
  - 寄存器相对寻址时，操作数的有效地址分为两部分：
  
    - 一部分存于**寄存器**中，指令中给出该寄存器名；
    - 另一部分以**偏移量**的方式直接在指令中给出。
  
  - 有效地址EA为基址寄存器（BX，BP，SI，DI）的内容加偏移量。EA为BP时，默认段为SS，EA为BX时默认段则为DS
  
    - 当EA=(BX/SI/DI)+DISP时，PA=(DS)*16+EA
    - 当EA=(BP)+DISP时，PA=(SS)*16+EA
  
  - 偏移量是符号数
  
    - ８位偏移量的取值范围为：0~0FFH（即+127~ -128）
    - 16 位偏移量的范围：0~0FFFFH（即+32767~ -32768）
  
  - 表现形式：[寄存器+偏移量]=[寄存器]偏移量=[寄存器]+偏移量
  - `MOV BX, COUNT [SI] ;` 等价于`MOV BX，[COUNT＋SI]`等价于`MOV BX [SI]+COUNT`


```assembly
;若DS=3000H,SI=2000H,COUNT=400OH，(36000H)=5678H，
MOV BX, COUNT [SI]
;物理地址=16×DS+SI+COUNT=36000H，执行后BX=5678H
```


- **基址加变址寻址**

  - 基址变址寻址时操作数的 EA 分为两部分，分别存于两个寄存器中：

    - 一部分存于基址寄存器(BX或BP)中；
    - 另一部分存于变址寄存器(SI或DI)中；
  - 有效地址EA为基址寄存器（BX，BP）的内容加偏移量。EA为BP时，默认段为SS，EA为BX时默认段则为DS

    - 当EA=(BX)时，PA=(DS)*16+EA
    - 当EA=(BP)时，PA=(SS)*16+EA
  - 优点
    - 这种寻址方式可用于表格或数组数据的访问操作。使用时将表格或数组首址作为位移量，用寄存器记录下标，通过修改SI、DI、BX或BP的内容，就可以访问不同的数组元素。
  - 表现形式：[基址寄存器+变址寄存器]或[基址寄存器]\[变址寄存器]
  - `MOV AX，[BX][SI];` 等价于`MOV AX，[BX+SI]`

```assembly
MOV AL,[BX][SI];
;设DS=4000H，BX=2000H, SI=1200H
;PA=DS*16+BX+SI=40000H=2000H+1200H=43200H
```


- **相对基址加变址寻址**


  - 采用相对基址变址寻址时，操作数的有效地址分为三部分：

      - 一部分存于变址寄存器 SI 或 DI 中；
      - 一部分存于基址寄存器 BX 或 BP 中；
      - 一部分为偏移量。
      - 指令中分别给出两个寄存器名及8位或16位的偏移量。
      - 效地址EA为基址寄存器（BX，BP）的内容加偏移量。EA为BP时，默认段为SS，EA为BX时默认段则为DS
      
        - 当EA=(BX)时，PA=(DS)*16+EA
        - 当EA=(BP)时，PA=(SS)*16+EA
      
      - 优点
      
          - 这种寻址方式也可用于表格或数组数据的访问。将表格或数组首地址存入基址寄存器，通过修改变址寄存器内容可访问到表格或数组的任一数据项的存储单元。由于这种寻址方式两个寄存器内容都可修改，因此它比寄存器相对寻址更灵活。
      - `MOV AX，MASK[BX][SI];`等价于`MOV AX，[MASK+BX+SI]`等价与`MOV AX, MASK[BX+SI]`


```assembly
;设DS＝5000H；BX＝2000H；SI＝1050H
MOV AX, 10H[BX][SI]
;PA=DS*16+10H+BX+SI=50000H+10H+2000H+1050H=53060H
```


- **I/O端口寻址**
  - I/O接口电路由接口寄存器组成，需要用编号区别各个寄存器：**编号＝地址**
  - *I/O地址是接口电路中寄存器的编号
  - 端口**是I/O地址的通俗说法**
  - **系统通过这些**端口与外设进行通信
  - 采用十六进制数来表达端口
  
    - Intel 8086支持64K个8位端口
    - I/O地址可以表示为：0000H~FFFFH
    - PC机支持1K个8位端口
    - I/O地址可以表示为：000H~3FFH

```assembly
1.端口直接寻址
    端口地址用8位立即数(0～255)表示。
    例如：IN  AL, 21H
2.端口间接寻址
    当I/O端口地址大于FFH时，必须事先将端口地址存放在DX寄存器中。
    例如:
    MOV  DX, 120H
    OUT  AX, DX
```


- **指令寻址方式**

  - 指令寻址方式是指确定下一条将要执行指令地址的方法，有顺序寻址方式和跳转寻址方式两种。
  - 由于指令地址在内存中顺序安排，当执行一段程序时，通常是一条接一条地顺序进行。这种顺序执行的过程，称为指令的顺序寻址方式。8086中程序指令在代码段中，由CS寄存器指定段地址，IP寄存器指定偏移地址，逻辑地址CS:IP所形成的物理地址就是指令地址，CPU每取一个指令字节，IP自动＋1，实现指令的顺序寻址。
  - 当程序执行的顺序发生转移时，指令的地址就采取跳转寻址方式。所谓跳转，是指将要执行的下一条指令的地址不是由当前IP+1顺序给出,而是由当前正在执行的指令给出。程序跳转后，从新的指令地址开始顺序执行。因此，CS、IP寄存器的内容也相应改变，跟踪新的指令地址。

- **隐含寻址**
  - 隐含一个或两个操作数
  - DAA：操作数存放于规定位置
- **转移类指令寻址**

  - 跳转寻址方式由程序控制类指令实现，如转移指令、子程序调用指令等。程序控制类指令使程序转移到目标地址﹐从目标地址开始执行程序。目标地址既可以和程序控制指令在同一个逻辑段内，也可以在不同的逻辑段内。在同一个逻辑段内的转移，称为段内转移在不同逻辑段的转移，称为段间转移。无论是段内转移还是段间转移，都有两种寻址方式:直接寻址和间接寻址。
  - **段内直接寻址**

    - 在段内直接寻址方式中，程序控制指令中直接指明了目标地址，且指令与目标地址在同一个代码段中，即只改变IP寄存器的值而不改变CS寄存器的值。
    - `指令名 SHORT 目标地址号`：短转移
    - `指令名 NEAR PTR 目标地址好`：近转移，PTR相当于强制类型转换
    - `指令名目标地址号`
    - 汇编段内直接指令寻址方式时，汇编程序计算转移目标地址标号与IP寄存器当前值(本条指令的下一条指令的地址)的差值，将其补码作为位移量，写人指令的地址码字段。位移量可以是一个带符号的8位数或16位数，当位移量为负时，表示向后转移;当位移量为正时，表示向前转移。在汇编格式中，如果符号地址前加SHORT，则表示位移量被强制为8位，跳转范围为-128~+127，称为短转移;如果符号地址前加NEAR PTR，则表示位移量被强制为16位，跳转范围为-32768~+32767，即允许转移到当前代码段内的任何位置，称为近转移;若什么都没加﹐默认为l6位。
    - 当执行这种寻址方式的转移指令时，机器取出位移量，与当前(IP)相加，将其和送入IP寄存器中，cS寄存器内容保持不变，从而实现指令的转移

  - **段内间接寻址**

    - 在段内直接寻址方式中，程序控制指令中直接指明了目标地址，且指令与目标地址在同一个代码段中，即只改变IP寄存器的值而不改变CS寄存器的值。
    - `指令名 16位寄存器`
    - `指令名 WORD PTR 存储器寻址方式`
    - `指令名 存储器寻址方式`
    - 汇编段内间接指令寻址方式时，汇编程序按格式中规定的寻址方式填写地址码字段。当执行这种寻址方式的转移指令时，机器按照指令中规定的寻址方式寻址到一个字，然后把它送入IP寄存器中，CS寄存器的内容不变，从而实现转移

  - **段间直接寻址**

    - 在段间直接寻址方式中，要转向的目标地址与程序控制指令处于不同的代码段，指令中直接给出目标地址，此转移地址用地址标号或数值地址表示。
    - `指令名 FAR PTR 目标地址号`
    - `指令名 地址:段偏移地址`
    - 段间直接指令不仅改变IP寄存器的值﹐而且改变CS寄存器的值。
    - 汇编这种指令寻址方式时，汇编程序将转移目标地址标号所在段的段地址及段内偏移地址值写入指令的地址码字段。
    - 当执行段间直接寻址方式的转移指令时，机器取指令操作码之后的第1个字送入IP寄存器中，取操作码之后的第2个字送入CS寄存器中，从而实现转移

  - **段间间接寻址**

    - 在段间间接寻址方式中，指令与转向的目标地址在不同的代码段，转移的目标地址放在存储器中，可以使用任何一种存储器寻址方式。在段间间接转移中，不仅改变IP寄存器的值，而且改变CS寄存器的值，因此存放转向地址的单元必须是一个双字类型的变量，用来分别存放转向地址的偏移地址和段地址。
    - `指令名 DWORD PTR 存储器寻址方式`
    - 汇编这种指令寻址方式时，汇编程序按格式中规定的寻址方式填写地址码字段。当执行这种寻址方式的转移指令时，机器按照指令中规定的寻址方式寻址到存储器中相继的两个字，把第1个字送入IP寄存器中，把第2个字送入CS寄存器中，从而实现转移


### 8086指令系统

- 程序是指令的有序集合
- 不同的CPU有各自的指令系统
  - 机器指令：用二进制码表示
  - 汇编指令：用助记符表示
- 8086指令共115条，分为六大类
  - 数据传送指令
  - 算术运算指令
  - 逻辑运算与循环移位指令
  - 字符串处理指令
  - 控制转移指令
  - CPU控制指令

#### 数据传送指令

- 通过数据传送指令
- **MOV** 传送
  - 格式：`MOV 目的操作数,源操作数 ; 目的(DST)<-源(SRC)`
  - 含义：将源操作数中的内容复制存入目的操作数中
  - 说明：
    - 指令种两个操作数不能同为存储器操作数
    - CS不能作为目的操作数
    - 段寄存器之间不能互相传送
    - 立即数不能直接送入段寄存器
    - MOV指令不影响标志位
  - 大小端对其（大小端方案/大小端模式）
    - 小端对其：低地址存放低8位，高地址存放高8位
    - 大端对其：低地址存放高8位，高地址存放低8位
- **堆栈操作指令**
  - 堆栈是由若干个连续存储单元组成的一段存储区域,按照“后进先出”的原则存取信息堆栈设置在堆栈段SS内，存取数据遵循以下原则:
    - 堆栈的存取每次必须是一个字(16位)，即堆栈指令中的操作数必须是16位，而且只能是寄存器或存储器操作数，不能是立即数。
    - 存放数据时，从高地址向低地址方向增长，取数据时相反。
    - 堆栈指针SP总是指向栈顶，即 SP的内容等于当前栈顶的偏移地址。
    - 对堆栈的操作遵循“后进先出”或”先进后出“的原则
  - 在程序中使用堆栈操作指令时，应预置堆栈段寄存器SS、堆栈指针SP的值，使SP的内容为当前堆栈的栈顶。
  - 执行进栈指令PUSH时，先将当前堆栈指针SP-2→SP，然后把源操作数送至SP所指堆栈顶部的一个字单元(两个连续字节单元)中;出栈指令POP把当前SP指向的堆栈顶部的一个字单元(两个连续字节单元)送至指定的目标操作数，然后修改栈顶指针 SP＋2→SP，使堆栈指针指向新的栈顶。
  - 说明
    - PUSH、POP指令不能使用立即寻址方式，POP指令不能使用CS寄存器
    - 堆栈中数据的压入，弹出必须以字为单位进行，每次PUSH操作栈顶向低地址移动两字节，而每次POP操作栈顶向高地址移动两字节
    - 这两条指令不影响标志位
    - PUSH、POP必须配对使用，保证SP指针不被破坏，这样才能保证在程序执行期间，堆栈不会发生溢出
  - 源
    - 16位通用寄存器
    - 段寄存器
    - 存储单元
    - 不能为立即数
  - **PUSH** 入栈
    - 格式：`PUSH 源 ;SP<-SP-2,源操作数（字）入栈`
    - 将高8位压入低地址，将低8位压入低地址
    - SP为`FFFEH~0`之间的偶地址
  - **POP** 出栈
    - 低地址存入低8位，高地址存入高8位
    - 格式：`POP 目的; 目的<-栈顶字，SP<-SP+2`
- **XCHG** 数据交换指令
  - 数据交换指令XCHG可以把源操作数和目标操作数交换，允许在寄存器之间、寄存器和存储单元之间完成一个字或字节的交换。
  - 格式：`XCHG 目的(DST)，源(SRC) ;DST<-SRC`
  - 要求
    - 不区分目的和源操作数
    - DST、SRC不允许使用段寄存器、立即数和IP寄存器
    - DST和SRC中，必须有一个寄存器寻址方式，及两个存储单元之间不能直接互换数据
    - XCHG指令不影响标志位


```assembly
;例： 设AX=2022H， DS=3000H，BX=1800H，（31A00H）=1984H
XCHG AX,[BX+200H] ;寻址方式
;执行后： AX=1984H，（31A00H）=2022H
```

- **XLAT** 查表指令(换码指令)
  - 可通过查表的方式，用表格中的一个值来置换AL中的内容，在执行指令前必须建立好一张翻译表
  - 格式：`XLAT [表首地址]; BX<-表首地址，AL<-偏移量; AL<-结果`
  

```assembly
查表求n的段码，查表，BX表首地址加上AL你给出的偏移量，然后得出的结果给AL
TAB : DB 40H,79H,24H,3OH,19H DB12H,02H,78H,OOH，18H 
MOV AL,n
MOV BX, OFFSET TAB
XLAT ;(AL) <- (BX+AL)
```

- **I/O** 指令
  - 完成累加器(AX/AL)于I/O端口之间的数据传送
  - 端口形式
    - 直接寻址：指令中的I/O端口地址为8位，此时允许寻址256个端口，端口地址范围为0~FFH
    - 寄存器间接寻址：端口地址为16位，由DX寄存器指定，可寻址64K(65535)个端口，地址范围为FFFFH
  
  - 注意
    - 指令中使用的数据寄存器必须是AL或AX
    - 间接寻址的
  
  - **IN** 输入指令，用于I/O端口读数据到累加器AL或AX中
    - 格式：
    - `IN AL/AX, 端口地址 ;8位地址`
    - `IN AL/AX, DX ;16位地址`
  - **OUT** 输出指令，用于把累加器AL或AX的内容写到I/O端口
    - 格式：
    - `OUT 端口地址, AL/AX ;8位地址` 
    - `OUT DX, AL/AX ;16位地址`
  

```assembly
例：
IN AL,OF1H ;输入8位
IN AX,80H  ;送16位，端口地址80H,81H中内容->AX

MOV DX,310H ;如果端口地址是16位的话，需要先送DX，再送AL
IN AL,DX

OUT 85H, AL ;输出8位

MOV DX, OFF4H ;输出16位
OUT DX, AL ;AL中内容从地址为OFF4H端口输出
```

- **地址目标传送指令**
  
  - > 地址传送指令是一类专用于传送地址码的指令，将内存操作数得逻辑地址(段地址或偏移地址)传送至指定寄存器中，共包括3种指令：LEA、LDS、LES
  
  - **LEA**：取有效地址指令，LEA把源操作数的有效地址(即16位的偏移地址)送入指定的寄存器中。
  
    - 格式：`LEA 目的(REG), 源(SRC); 目的<-源存储单元有效地址`
    - 目的操作数必须为一个16位的通用寄存器
    - 目的操作数不能是段寄存器
    - LEA不影响标志位
  
  - **LDS** 双字指针->寄存器和DS
  
    - LDS和LES不影响标志位
    - LDS指令将源操作数SRC指定的4个连续字节中的内容作为地址，送入指定的寄存器中。其中﹐前两字节作为偏移地址传送到目的操作数REG中;后两字节作为段地址传送到DS中.
    - 格式：`LDS 目的(REG)，源(SRC) ;目的<-源，DS<-源+2`
    - 目的：常用SI
  
  - **LES** 双字指针->寄存器和ES
  
    - LES与LDS相似，但将段地址送到ES中。
    - 格式：`LES 目的,源 ;目的<-源，ES<-源+2`
  

```assembly
;LEA，例
LEA BX, TAB 等价于 MOV BX, OFFSET TAB
;设SI=1000H,DS=5000H,(51000H)=1234H,则：
LEA BX, [SI]; 
;执行后：BX=1000H	LEA将偏移地址送给BX
MOV BX, [SI];
;执行后：BX=1234H	MOV将偏移地址和数据段的数送给BX	
```

```assembly
;LDS 例，这条指令取两个16位，一个送到指定的SI中，一个送到默认的DS数据段中
;设DS=1200H，BX=0020H，（12450H）=F346H，（12452H）=0A90H
LDS SI,[450H];
;执行后：SI=F346H DS=0A90H
```

- **标志传送指令**（用于FLAGS）
  - **LAHF**
    - 读取标志指令
    - FR寄存器低八位传送至AH指令LAHF
    - ![image-20220926095656075](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209261208652.png)
  - **SAHF**
    - 设置标志指令
    - AH内容送FR寄存器低八位指令SAHF
    - 常在子程序调用及中断过程：保护/恢复标志
    - ![image-20220926095727598](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209261208595.png)
  - **PUSHF**
    - 标志寄存器进栈指令
    - 格式：`PUSHF; FR->[SS*16+SP-2]`
  - **POPF**
    - 标志寄存器出栈指令POPF
      - 格式：`POPF; FR->[SS*16+SP],SP+2-SP`

#### 算数运算指令

- 包括加、减、乘、除4类运算

- 绝大部分指令影响标志位

- 可处理4位类型数据

- | 二(B)    | 十六(H) | 无符号(D) | 带符号(D) | 非压缩(BCD) | 压缩(BCD) |
  | -------- | ------- | --------- | --------- | ----------- | --------- |
  | 00000111 | 07      | 7         | +7        | 7           | 07        |
  | 10001001 | 89      | 137       | -119      | 无效        | 89        |
  | 11000101 | C5      | 197       | -59       | 无效        | 无效      |


##### 加

- **ADD** 不带进位加法指令
  - 格式：`ADD 目的, 源;  目的<-源+目的`
  - 源：寄存器，存储器
  - 目的：寄存器，存储器，立即数
  - 对标志位影响：CF、OF、AF、SF、ZF、PF
- **ADC** 带进位的加法
  - 在两个操作数相加时，要把进位标志CF加上去。ADC指令的操作数都是带符号数。
  - 格式：`ADC 目的, 源; 目的<-源+目的+CF`
  - 对标志位的影响：与加法指令ADD相同
  

```assembly
MOV AX, [0100H]
ADD AX, [0200H] ;低16位相加
MOV [0300H],AX	;低16位之和存入0300H，0301H单元
MOV AX, [0100H]+2 ;装入高16位
ADC AX, [0200H]+2 ;高16位求和，考虑16位的进位
MOV [0304H],AX ;将16位之和存入0302H、0303H单元
```

- **INC** 增量指令（自动增1）
  - 格式：`INC 目的 ; 目的<-目的+1`
  - 对标志位影响：OF、AF、SF、ZF、PF，不影响CF

```assembly
INC BL
INC CX
INC WORD PTR [BX]
;PTR代表属性说明，操作数在[BX]中的属性单元中，WORD就代表对16位数进行操作，不加属性说明就代表按字节加
```

- **AAA**  加法的非压缩BCD调整
  - 格式：`AAA` 
  - 对两个非压缩BCD数相加后位于AL中的和进行调整
  - 使其仍未非压缩BCD，并将结果->AX

```assembly
设AL=BCD9， BL=BCD5
ADD AL,BL ; AL=OEH
AAA       ; AX=0104H,CF=AF=1
		  ; 对于ASCLL，再加一条OR AX，3030H
```

- **DAA** 加法的压缩BCD调整
  - 格式：`DAA`
  - 将两个压缩BCD数相加后位于AL的和调整为压缩BCD->AL

```assembly
设AL=38H, BL=50HM, CL=49H
ADD AL,BL  ; AL=88H
DAA        ; AL=88H
ADD AL,CL  ; AL=88H+49H=D1H
DAA        ; AL=37H,CF=1

校正方法：
	若AL低4位>9或AF=1，则：
	AL<-AL+6，调整低4位；
	若此时AL高4位>9或CF=1，则：
	AL<-AL+60H，调整高4位，且CF=1，
	否则CF清0
```

##### 减

- **SUB** 不带借位减法指令
  - 格式：`SUB 目的，源; 目的<-目的-源`
  - 对标志位影响：CF、OF、AF、SF、ZF、PF
- **SBB** 带借位的减法指令
  - 格式：`SBB 目的，源; 目的<-目的-源-CF`
  - 主要用于做多字节、多精度减法，应为它能够减去低位产生的借位
  - 对标志位影响：与SUB相同
- **DEC** 减量指令（自动减1）
  - 格式：`DEC 目的; 目的<-目的-1,不影响CF`
  - 对标志位影响：OF、AF、SF、PF、ZF，对CF不影响
- **NEG** 取(补\反\负)指令
  - 格式：`NEG 目的; 目的<-0-目的，求(补\反\负)码`
  - 对标志位影响：CF、OF、AF、SF、ZF、PF
- **CMP** 比较指令
  - 执行减法操作，相减的结果不送回目标操作数，仅改变标志寄存器的内容，两操作数的值保持不变。CMP指令的操作数可以是带符号数，也可以是无符号数。
  - 格式：`CMP 目的，源;目的-源，不回送结果但影响FLAGS`
  - 对标志位影响：ZF、CF、SF、OF、PF、AF
  

```assembly
设AL=B1H，DL=4AH
SUB AL,DL; AL=67H  （CF:0，AF:1，ZF:0，SF:0，OF:1，PF:0）
CMP AL,DL; AL不变，FLAGS同上

CMP AX,BX
		ZF=1,则AX=BX
无符号数：CF=0，则AX>BX
		CF=1，则AX<BX
有符号数：OF=SF=1，则AX>BX
		OF≠SF，则AX<BX
		AX>=BX，OF=SF或ZF=1
		AX<=BX，OF≠SF或ZF=1
```

-  **AAS** 减法的非压缩BCD调整/ASCLL调整

```assembly
设AL=BCD3，BL=BCD8，则:
SUB AL,BL ; AL=FBH
AAS       ; AL=BCD5,CF=1

 00000011
-00001000
=11111011
```

- **DAS** 减法的压缩BCD调整

```assembly
设AL=56H，CL=98H
SUB AL,CL; AL=56H-98H=BEH
DAS      ; AL=58H,CF=1
```

##### 乘

MUL指令和 IMUL指令只提供一个源操作数，可以是除立即数外的任何寻址方式，另一操作数隐含为累加器AL或AX。两个8位数相乘结果存于AX中，两个16位数相乘结果存于DX、AX中，DX存放高16位，AX存放低16位。

MUI和IMUI指令分别用于无符号数和带符号数的相乘运算。例如﹐(11111111)*(11111111B)，若看作无符号数，则使用MUL指令，执行的结果为255×255=65025;若看作带符号数，则使用IMUL指令，执行的结果为(-1)(-1)=1.

- **MUL** 无符号数乘法
  - 格式：`MUL 源; AX<-AL*源 (字节乘) | DX,AX<-AL*源 (字乘)`
  - 对除CF和OF以外的标志位无定义(即指令执行后,标志位的状态不确定)
  - 若结果的高半部分(字节乘为AH，字乘为DX≠0，CF=OF=1，字乘为DX=0，CF=OF=0)
  - 源：不能为立即数

```assembly
MUL DL 		;AX<-AL*DL
MUL CX 		;DX,AX<-AX*CX
MUL B[SI]   ;AX<-AL*内存中的字节
MUL W[BX]	;DX,AX<-AX*内存中字
```

- **IMUL** 带符号数乘法
  - 格式：`IMUL 源: AX<-AL*源 (字节乘) | DX,AX<-AX*源(字乘)`
  - 对除CF和OF以外的标志位无定义(即指令执行后,标志位的状态不确定)
  - 若结果的高半部分（AH或DX）为全0或全1，CF=OF=0，表明为符号扩展位;否则，CF=OF=1，表明为乘积的高位
- **AAM** 无符号数乘法的非压缩BCD调整; 调整AL中的非压缩BCD乘积->AX

```assembly
MOV AL, 09H
MOV BL, 06H
MUL BL		; AL=36H
AAM 		; AX=0504H

;ASCLL码作乘法前，需先将高4位清0
```

##### 除

- **DIV** 无符号数除法指令； FLAGS无定义
  - 格式：`DIV 源;`

```assembly
AL<-AX/源（B）的商(最大为FFH)
AH<-余数
AX<-DX,AX/源(W)的商（最大为FFFFH）
DX<-余数
```

- **IDIV** 带符号数除法
  - 格式：`IDIV 源; 余数的符号与被除数相同`
  - ;字节除:商值范围:-128~+127
  - ;字除:商值范围:-32768~+32767

```assembly
除法运算要求被除数是除数的2倍长度，
即，16/8或32/16，否则需扩展高位
扩展方法：将符号位扩展至高位寄存器的所有位
```

- **CBW** 扩展字节为字
  - 将AL内容扩展至AX
  - 有符号数：
    - 正数：左侧补0，AH=00H
    - 负数：左侧补1，AH=FFH

  - 无符号数
    - 左侧补0，AH=00H


```assembly
   AH		     AL
00000000	  0xxxxxxx
11111111	  1xxxxxxx
```

- **CWD** 扩展字为双字
  - 将AX中的内容扩展至DX AX
  - 有符号数
    - 正数：左侧补0，DX=0000H
    - 负数：左侧补1，DX=FFFFH

  - 无符号数
    - 左侧补0，DX=0000H


```assembly
   	   DX			  		   AX
0000000000000000		0xxxxxxxxxxxxxxx
1111111111111111		1xxxxxxxxxxxxxxx
```

- **AAD** 除法的非压缩BCD调整
  - ; 做除法前，将BCD转换为二进制数

```assembly
设AX=0307H，BL=05H，求AX/BL=？
AAD			; AL=25H
DIV BL		; AX=0207H

；若为压缩BCD，需优化为非压缩BCD
```

#### 逻辑运算与循环移位指令

##### 逻辑运算指令

源操作数可以是立即数、通用寄存器或存储器操作数

目标操作数可以是通用寄存器或存储器操作数，但不可以是立即数

都可以进行字节或字的按位逻辑运算

NOT指令不影响标志位，其余四条都使CF和OF为0，对AF无定义，按运算结果设置SF、PF、ZF

- **NOT** 逻辑非
  - 格式：NOT 目的; 目的<-目的(非)

```assembly
NOT AX
NOT BL
NOT BYTE [BX]

以下双逻辑操作数逻辑指令执行后：CF=OF=0；ZF，SF，PF反应结果
```

- **AND** 逻辑与
  - 格式：`AND 目的, 源; 目的<-目的∧源`
  - 与0相与,清0；与1相与,不变

```assembly
设AX=3538H，则：AND AX,OFOFH   --->AX=0508H
```

- **OR** 逻辑或
  - 格式：`OR 目的,源; 目的<-目的∨源`
  - 与0相或,不变，与1相或,置1

```assembly
设AX=0508H，则：OR AX,3030H    --->AX=3538H
```

- **XOR** 异或
  - `格式：XOR 目的,源; 目的<-目的 ⊕ 源 ;`
  - ; X⊕0=X;X⊕1=X(非)
  - 相同为0，不同为1
  - 如果`目的`和`源`两个值不相同，则异或结果为1。如果`目的`和`源`两个值相同，异或结果为0。

```assembly
IN AL,61H ; 端口61H的D1位控制扬声器
XOR AL, 00000010B
OUT 61H, AL
```

- **TEST** 测试指令
  - 格式：`TEST 目的, 源; 目的∧源，不回送结果，但影响FLAGS`

```assembly
TEST AL,80H; 测AL中第7位
JNZ T_ALARM; D7=1,转温度报警
TEST AL,40H; 测D6位
JNZ P_ALAR; D6=1,转压力报警
... ... ...
```

##### 移位指令

> 移位指令影响标志位CF、PF、SF、ZF、OF。OF的设置方法是:如果移位后最高位发生了变化，则OF=1，否则OF=0。其余标志位根据移位后的值来确定，对AF无定义。

- **SHL** **SAL** 算数/逻辑左移
  - 格式：`SHL/SAL 目的, 计数值`
  - 计数值：移位次数，1次或者CL(多次)
  - ;CF<-MSB<-LSB<-0
  - ;移位后，若最高位≠CF，则OF=1；若最高位=CF，则OF=0
  - ;左移1位，相当于乘2

```assembly
MOV AH, 06H
SAL AH, 1
MOV CL, 03H
SHL DI, CL
SAL BYTE PTR [BX], 1
```

- **SHR** 逻辑右移
  - 格式：`SHR 目的, 计数值`
  - 右移一次，无符号数相当于除以2(余数丢弃)
  - 一般为指代符号数

```assembly
MOV AL, 10000110B; AL=134
SHR AL, 1		 ; AL=67
SHR AL, 1 		 ; AL=33, CF=1
```

- **SAR** 算数右移
  - 格式：`SAR 目的, 计数值;`
  - 右移一次，相当与用补码表示的带符号数除以2
  - 符号位不变，指代有符号数

```assembly
MOV AL, 80H; AL=1000000B=-128
MOV CL, 03H
SAR AL, CL;  AL=1110000B=FOH=-16
```

##### 循环移位指令

> 循环移位指令只影响标志位CF和OF，不影响其他标志位。CF根据移位后的值来设置，OF的设置方法是:如果移位前后最高位的值发生了变化，则OF=1，否则OF=O。

- **ROL** 循环左移
  - 格式：`ROL 目的, COUNT`
- **ROR** 循环右移
  - 格式：`ROR 目的, COUNT`
- **RCL** 带进位循环左移
  - 格式：`RCL 目的, COUNT`
- **RCR** 带进位循环右移
  - 格式：`ROR 目的, COUNT`

```assembly
MOV AL, 46H
MOV CL, 2
ROL AL,CL	;AL=19H,CF=1,OF=0
```

#### 字符串指令

- **CMPSB/W** 字符串比较指令
  - 格式：`CMPSB/W 目的串, 源串; 不影响串内容，但影响FLAGS`
  - 比较两个字符串：口令串PASSWORD和键盘输入字符串IN_WORD。若相同，程序向下执行；否则，喇叭响，拒绝执行
  - 例![image-20220727154206331](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271542209.png)

- **SCASB/W** 字符串扫描指令
  - 格式：`SCASB/W 目的串 ; AL/AX--目的串,不回送,但影响FLAGS`

```assembly
例：在字符串中查找关键字'A'
      MOV DI, OFFSET STRING	; DI<-字符串偏移地址
      MOV CX, COUNT			; CX<-串长度
      MOV AL, 'A'				; AL<-关键字'A'
      CLD
      PEPNE SCASB				; 不等且CX≠0时重复
      JZ FIND					; 查到，转FIND
      MOV DI, 0
FIND: MOV BX, DI
	  HLT
```

- **LODS** 字符串装入指令
  - 格式：`LODS 源串; AL/AX<-源串内容，DS:SI自动修改`
- **STOS** 数据传存储指令
  - 格式：`STOSB/W 目的串; 目的串单元<-AL/AX,ES:DI自动修改`
  - 目的串：常用于将某数据区填充相同的数

![image-20220727162823111](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207271628999.png)

#### 控制转移类指令

##### 无条件转移与过程调用返回指令

- **JMP** 无条件转移
  - 格式：`JMP 目的`
  - SHORT：表示位移量在-128~127字节之间，称为***短转移***，位移量用一个 字节（8位）来表示。
  - FAR：表示转移距离超过±32K字节，或是在不同段之间转移，称为***远转移***，因为程序控制超出了当前代码段，所以CS和IP都必须修改为新的值。
  - NEAR： 表示在同一段内转移，位移量在-32768~32767字节范围内，称为***近转移***，位移量用16位表示， 因为程序控制仍然在当前代码段，所以只修改IP的值，CS的值不变。
  - 4种类型
    - 段内直接转移：段不变，转向的偏移地址=IP当前+DISP(偏移量)
      - 在转移指令中直接给出 8 位或 16 位的相对位移量，指令转向的有效地址为: (当前IP的内容 +相对位移量)(IP)位移量为8位时，称段内直接短转移；位移量为16位时，称段内直接近转移
      - `JMP SHORT PTR 标号;` 8位DISP，转移范围：-128~+127
      - `JMP NEAR PTR 标号;` 16位DISP，范围：-32768~+32767 
    - 段内间接转移
      - 由转移指令中指定一个16位寄存器或存储器字单元的内容做为转移的有效地址，直接取代（IP）的内容。
      - `JMP BX; 若BX=4500H,则转向4500H处`
    - 段间直接转移
      - 转移指令中直接给出了转向目标的段基址和段内偏移地址，用此地址分别取代（CS）和（IP）中的内容，完成从当前段向另一个段的转移
      - `JMP FAR PTR PROG_F;` 跳到另一个段
      - FAR：属性说明跳到比较远的地址，不是8和16位
    - 段间间接转移
      - 在转移指令中给出一个存储单元的地址，用该地址所指的两个相邻字单元的内容（32位）来取代（CS）和（IP）中的内容，从而达到段间转移的目的。 
      - `JMP DWORD PTR [SI+0125H]`

```assembly
// 段内直接转移
例：地址	 机器码	PROG_S：ADD  AL, 05H
   0000	    0405		 	NOP
   0002	  	90				JMP SHORT PROG_S
   0005		90				NOP
DISP=目的地址-IP当前=0000H-0005H=-5

// 段内间接转移
设DS=2000H，BX=100H，(20105H)=4F0H,则
JMP WORD PTR 5 [BX] ;IP=DS*16D+BX+5H=(20000+100+5)=4F0H

// 段间直接寻址方式
JMP FAR PTR OUTSEG 
因为是段间转移，CS和IP都要更新，这个新的段地址和偏移地址由OUTSEG，只要将指令中OUTSEG的低字装入IP，高字装入CS，就完成了从一个段到另一个段转移的工作。

// 段间间接转移
执行前：CS=1200H，IP=05H，DS=2500H SI=1300H，（26425H）=4500H (26427H)=32F0H
执行：JMP DWORD PTR [SI+0125H]
IP=16×DS+SI=16*2500H+1300H=25000H+1300H+0125H=26425H
CS=16×DS+SI+2=16*2500H+1300H=25000H+1300H+0125H+2=26427H
执行后：转向CS:IP=>32F0H:4500H
```

- **CALL RET 过程调用与返回指令**

![image-20220728143826977](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202207281438801.png)

```assembly
调用：CALL 过程名： 
  保护断点：SP<-SP-2,CS入栈
  		  SP<-SP-2,IP入栈
  转子程序入口（与JMP方法一样）
  
返回：RET	; IP<-(栈顶字),SP<-SP+2
		    CS<-(栈顶字),SP<-SP+2（仅对远调用）
		    
返回：RET n; 弹出断电后，再弹出n个字节，SP<-SP+n
```

##### 条件转移指令

- 全为段内短转移

| 助记符 | 功能         | 测试条件     |
| ------ | ------------ | ------------ |
| JC     | 有进位/借位  | CF=1         |
| JNC    | 无进位/借位  | CF=0         |
| JZ/JE  | 结果为0/相等 | ZF=1         |
| JNZ    | 结果非0/不等 | ZF=0         |
| JS     | 为负         | SF=1         |
| JNS    | 为正         | SF=0         |
| JO     | 溢出         | OF=1         |
| JNO    | 无溢出       | OF=0         |
| JP     | 奇偶位为1    | PF=1         |
| JNP    | 奇偶位为0    | PF=0         |
| JA     | 高于         | CF=0         |
| JAE    | 高于等于     | CF∨ZF=0      |
| JB     | 低于         | CF=1         |
| JBE    | 低于等于     | CF∨ZF=1      |
| JG     | 大于         | SF⊕OF=1      |
| JGE    | 大于等于     | (SF⊕OF)∨ZF=0 |
| JL     | 小于         | SF⊕OF=1      |
| JLE    | 小于等于     | (SF⊕OF)∨ZF=1 |

- Above/Below：用于无符号数
- Great/Less：用于带符号数

```assembly
例1．某学生英语成绩在AL中,试编写程序，当
AL<60,	 打印F
60≤AL85，打印P
AL≥85,   打印G

---
    CMP AL,60
    JB FAIL
    CMP AL,85
    JAE GOOD
    MOV AL, 'P'
    JMP PRINT
FAIL:MOV AL, 'F'
	 JMP PRINT
GOOD:MOV AL, 'G'
PRINT: ......
```

```assembly
例2.10个符号数存于TAB为首址的单元中,试统计其中正、负及0的个数。

---
        MOV CX, 10
        MOV BX, 0
AGAIN:  CMP TAB[BX],0
		JGE GT_EQ
		INC NEGT; 负数个数+1
		JMP NEXT
GT_EQ:  JG P_INC
		INC ZERO; 0个数+1
P_INC:  INC PLUS; 正数个数+1
 NEXT:  INC BX
 		DEC CX
 		JNZ AGAIN
```

```assembly
例3.某温度控制系统,从温度传感器(端口地址320H)获得温度值→A/D→AL。试编程实现:
当AL二100c,启动加热器
AL≥100c,关闭加热器

---
GET_TEMP: MOV DX, 320H
		  IN AL, 100		;读取温度->AL
		  CMP AL, 100
		  JB HEAT_ON		;<100,转加热
		  JMP HEAT_OFF		;>=100,停止加热
HEAT_ON:  MOV AL, 01H
		  MOV DX, 321H		;加热器口地址->DX
		  OUT DX, AL		;打开加热器
		  JMP GET_TEMP		;继续检测
HEAT_OFF: MOV AL,0
		  MOV DX, 321H
		  OUT DX, AL		;关闭加热器
```

#### 循环控制指令

- **LOOP (短)标号; 循环**

```assembly
	   MOV CX, 10
DELAY: LOOP DELAY
```

- **LOOPE/LOOPZ 标号 ; 相等/结果为0，循环**

- **LOOPNE/LOOPNZ 标号; 不相等/不为0，循环**
- **JCXZ; CX=0, 转移**

```assembly
STRING开始存放一个字符串，共17个字符。编程查找是否有空格符号

---
STRING: DB   'Personal Computer'
		......
		MOV BX,OFFSET STRING
		DEC BX
		MOV CX,	17
  NEXT: INC BX
  		CMP [BX], 20H   ;ASCLL码中20就是空格符号
  		LOOPNE NEXT
  		......
```

![image-20220801101145031](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011031916.png)

```assembly
例:控制PC机扬声器发声程序。硬件:61H端口D1 DO位接扬声器,Do=0时,D1的变化使扬声器发声

---
       IN  AL,  61H		;读端口数据
       AND AL,  OFCH	;D1=D0=0
   LP: XOR AL,  02H		;D1位取反
       OUT 61H, AL		;控制扬声器
	   MOV CX, 260
DELAY: LOOP DELAY		;延时
       JMP LP
```

#### 中断指令

- 中断的概念
  - 8086可处理256类中断，类型号位0~255。每类中断分配一个入口地址，占4个字节存放IP和CS
  - 最低5个类型位专用中断：除法错，单步，NMI，断点，溢出
  - ![image-20220801103220811](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011032630.png)

- **INTO ; 溢出中断**
  - 常跟在符号数运算后，一旦溢出，产生4号中断处理
- **IRET ; 中断返回**
  - 从栈顶一次弹出IP、CS、FLAGS，程序按CS:IP返回

- **INT n(中断类型号) ; 执行过程**
  - 保护标志与断点
    - FLAGS、断点(CS、IP)分别入栈
    - 清除IF、TF，以屏蔽中断、禁止跟踪
  - 中断响应
    - n*4得向量地址
    - 查向量表取入口地址->IP、CS
    - CPU自动转向CS:IP执行中断服务程序
  - ![image-20220801104713658](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011050039.png)

#### 处理器控制指令

- 标志操作指令（位操作）

```assembly
CF: CLC ; CF<-0
	CMC ; CF<-CF(非)
	STC ; CF<-1
DF: CLD ; DF<-0, 增址
	STD ; DF<-1, 减址
IF: CLI ; IF<-0, 关中断
	STI ; IF<-1, 开中断
```

- 外部同步指令
  - **ESC** 换码指令
    - 8087一旦检测到8086有ESC指令，立即响应，协助工作
  - **WALT** 等待指令
    - 执行ESC，8086不断检测TEST引脚，为高则执行WALT等待；为0则向下执行
  - **LOCK** 封锁总线指令
    - 指令前缀，使LOCK引脚有效，禁止其他主设备控制总线
  - **NOP** 空操作
    - 单字节，3周期，不做任何操作
  - **HLT** 停机
    - CPU暂停，下列之一可打断暂停
    - RESET
    - 中断请求，NMI,INTR

#### 软件延时

- 设8086F<sub>clk</sub>=5MHz，则T=0.2μs（附录：指令执行时间）

```assembly
1ms延时程序

---
DEL_1MS: MOV CX, ODAH	; 4 *1
   NEXT: NOP			; 3 *218
   		 NOP			; 3 *218
   		 LOOP			; 循环17，不循环5

t=(4+3*218+3*218+17*218+5)*0.2≈1ms
```

- 长延时：多重循环

```assembly
	 MOV BX, N1			; 4*1
LP1: MOV CX, N2			; 4*N1
LP2: LOOP LP2			; (17*N2-12)*N1
	 DEC BX				; 2*N1
	 JNZ LP1			; 16*N1-12
```

## 汇编语言程序设计

- 概述

  - 汇编语言
    - 用指令助记符、符号地址标号等编写的程序
    - 为机器语言得符号表示
    - ![image-20220801145715826](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011457641.png)

  - 汇编语言的特点
    - 高级语言
      - 可移植性好
      - 程序易编/易读/易学
      - 应用：科学计算、信息管理等
    - 汇编语言
      - 面向机器/硬件
      - 程序代码效率高
      - 执行速度块，占内存少
      - 应用：实时控制、仪器仪表、系统软件等
- .LST文件
- ![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011541997.png)
  - ![image-20220801151328051](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011544982.png)


### 汇编语言的语言格式

- 指令性语句：可执行语句，有对应的机器码
  - 格式：`标号: 助记符 操作数1，操作数2; 注释`
- 指示性语句：伪指令，无机器码
  - 格式：`名字 指示符 操作数1，操作数2; 注释`
- 数据项：操作数:常量、变量、标号
  - 常量：01101101B、38、5AH、0FEH、'AB'
  - 变量与标号：有三个属性：
    - 段值：变量/标号所在段的段地址
    - 偏移地址：
    - 类型：变量/标号：BYTE，WORD，DWORD/NEAR，FAR

### MASM中的运算符及表达式

- 算术运算符：`+` `-` `*` `/` `MOD`，`SHL`，`SHR`

```assembly
DA 	EQU 28
MOV	AX, DA-8		    ; 20
MOV BX, DA/5		    ; 5
MOV CX, DA MOD 5	    ; 3
MOV DH, 01100100B SHR 2 ; 00011001B
```

- 逻辑运算符：`AND`，`OR`，`XOR`，`NOT`

```assembly
MOV AL, NOT OFFH		;00H
MOV BL, 8CH AND 73H		;00H
MOV AH,	8CH OR  73H     ;FFH
MOV CH, 8CH XOR 73H		;FFH
```

- 关系运算符：`EQ`，`NE`，`LT`，`LE`，`GT`，`GE`

```assembly
MOV AX,10H GT 16	;0000H
ADD BL, 6 EQ 0110B  ;FFH
```

- 数据返回运算符：`OFFSET`，`SEG`，`TYPE`，`LENGTH`，`SIZE`
  - TYPE返回值：
    	变量：DB/DW/DD/DQ：1/2/4/8
    	标号：NEAR/FAR：-1/-2
  - LENGTH：使用DUP时，返回其单元数，其他情况返回1
  - SIZE=LENGTH*TYPE

```assembly
例：
MOV BX, OFFSET DA1
MOV BX, SEG M1
MOV DS, AX
```

```assembly
例：TYPE
---
A1 DB 20H, 30H
A2 DW 0438H
A3 DD ?
返回值
L1: MOV AH, TYPE A1; 1
	MOV BH, TYPE A2; 2
	ADD AL, TYPE A3; 4
	MOV BL, TYPE L1; OFFH
```

```assembly
例：LENGTH
---
M1  DW 100 DUP(?)
M2  DW 1,2,3
MOV CX, LENGTH M1	;100
MOV BL, LENGTH M2	;3
MOV CX, SIZE   M1	;200
MOV BL, SIZE   M2	;6
```

- 修改属性运算符：`PTR`，`THIS`，`HIGH`，`LOW`，`SHORT`

```assembly
MOV AX, ES: [BX]
N1 DB 15, 36H
N2 DW 1122H, 3344H
MOV AX, WORD PTR N1
JMP SHORT L2
K1 EQU 1234H
MOV AH, HIGH K1
```

### 伪指令语句

#### 数据定义语句

- `DB`，`DW`，`DD`，`DQ`，`DT`，`DUP()`
  - DB，字节定义
  - DW，字定义
  - DD，双字定义
  - DQ，8字节定义
  - DT，10字节定义
  - DUP(0)，括号里面如果是0，则给得地址内存单元内容默认为0，是1得话，默认为1

![image-20220801171804612](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208011721845.png)

```assembly
DA1 DB 10H, 52H
DA2 DW 1122H, 34H
......
FIRST DB "HELLO"
	  EVEN(对准存放的概念)
SECOND DW 'OK'
	   M1 DB ?
	   M2 DW 0D55H
ONE	   DB 3	 DUP(0)
TWO    DW 10 DUP(?)
```

- 表达赋值语句：`EQU`

```assembly
COUNT EQU  100
DATA  EQU  COUNT+2
B1	  EQU  OFFSET A1
C1 	  EQU  ADD
```

```assembly
DATA SEGMENT
LIST DB 12,38,5,29,74
COUNT EQU $-LIST	  ;$-LIST代表当前指令所在地址
DATA ENDS
	......
	......
MOV CX, COUNT
```

#### 段语句

- 段定义语句
  - 定位类型：表示该段的起始边界要求有PAGE/PARA/WORD/BYTE四种，分别以页/节/字/字节为边界
  - 组合类型：告诉链接程序，本段与其他段的组合关系共6种
    - NONE：本段与其他同名段不进行连接，各段独立（缺省值）
    - PUBLIC：该段与其他同名段相邻地连在一起，组成一个逻辑段
    - COMMON：链接程序为本段与其他同名段指定相同的段基址，采用覆盖方式存放，连接长度为各段中最大长度
    - AT表达式：链接程序把本段装在表达式的值所指定的段基地址处
    - STACK：指定该段的堆栈段，在堆栈段中不可省略，多个模块只需设置一个堆栈段，采用覆盖方式组合
    - MEMORY：将本段定位在被连接的其他同名段之后。
  - 类别：使所有类别相同的段组成一个段组
    - 典型类别：'STACK'、'CODE'、'DATA'

```assembly
段定义格式：
    段名 SEGMENT [定义类型][组合类型]['类别']
    	......
    段名 ENDS
```

- 设定段寄存器

```
ASSUME 段寄存器: 段名,[,段寄存器:段名,...]
```

- 段分配语句
  - 告诉汇编程序各段与段寄存器得关系，保证生成正确的目标程序

```assembly
CS: 指向代码段 自动将段基址->CS
DS: 数据段		--
SS: 堆栈段		  |--不能自动装入段基址，需初始化时装入
ES: 附加段		--
```

#### 过程定义语句

- 过程：与子程序一样，用CALL指令调用

```assembly
过程名 PROC [NEAR] 或 FAR
	  ......
	  RET
过程名 ENDP
```

#### 开始结束语句

```assembly
NAME 模块名
TITLE 标题 ; 指定每页打印的标题
ORG 表达式 ; 指定下面语句的起始偏移地址
END [标号] ; 汇编到此结束
```

#### 基本结构

```assembly
DSEG SEGMENT
 ...
DSEG ENDS
ESEG SEGMENT
 ...
ESEG ENDS
SSEG SEGMENT
 ...
SSEG ENDS
CSEG SEGMENT
 ASSUME CS:CSEG,DS:DSEG,ES:ESEG,SS:SSEG
START: MOV AX,DSEG
	   MOV DS,AX
	   
	   MOV AX ESEG
	   MOV ES,AX
	   
	   MOV AX,SSEG
	   MOV SS,AX
	   ...
	   MOV AH,3CH ;程序执行完返回操作系统，结束程序
	   INT 21H
CSEG ENDS
END START
```

### DOS功能调用和BIOS功能调用

![image-20220802105825629](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208021058149.png)

- DOS不仅提供了许多命令让用户直接使用，还提供一批子程序供用户直接调用，实现设备管理、文件管理、目录管理等。
- DOS规定用中断指令INT 21H进入各功能调用总入口，再为每个功能调用规定一个功能号，以便进入相应的子程序入口。

- DOS功能调用的步骤：
  - 系统功能号->AH
  - 调用参数->指定寄存器（入口参数：或在寄存器中或无参数）
  - INT 21H
  - 按规定取得出口参数（返回参数：或在寄存器中或直接显示等）

#### 键盘功能调用

- 1号功能调用：从键盘输入单字符并显示

```assembly
MOV AH, 1
INT 21H

;执行上述指令，系统将扫描键盘，一旦有键按下，就将键值(ASCLL)读入，线检查是否为Ctrl-Break，若是，则退出；否则，将键值->AL，同时将字符显示在屏幕上
```

```assembly
例：交互程序
KEY: MOV AH, 1
	 INT 21H
	 CMP AL, '1'
	 JE ONE
	 CMP AL, '2'
	 JE TWO
	 CMP AL, '3'
	 JE THREE
	 JMP KEY
ONE:   ......
TWO:   ......
THREE: ......
```

- 0AH号功能调用：从键盘接收字符串存入内存指定缓存区
  - DS:DX为缓存区首地址
  - ![image-20220802111400752](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208021114638.png)

- 0BH号功能调用：检查是否有键按下
  - AL=FFH有
  - AL=00H有

```assembly
LOOP: MOV AH, 0BH
	  INT 21H
	  INC AL
	  JNZ LOOP
	  CALL SOUND
```

- 其他键盘功能调用
  - 06H号：键盘输入/输出字符，不检查Ctrl-Break
  - 07H号：键盘输入/输出字符，无回显，不检查Ctrl-Break
  - 08H号：键盘输入一个字符，无回显
  - 0CH号：清键盘缓冲区，调用键盘输入功能

#### 显示功能调用

- 2号功能调用：将单字符送屏幕显示
  - 入口：字符->DL

```assembly
MOV DL, '*'
MOV AH, 2
INT 21H ; 在光标位置显示*
```

- 9号功能调用：显示字符串
  - 入口：字符串首址->DS:DX，'$'作结束符

```assembly
DATA SEGMENT
	CR EQU ODH ; 回车
	LF EQU OAH ; 换行
MES DB  'HOW DO YOU DO?' ,CR,LF,'$'
DATA ENDS
CODE SEGMENT
	  ASSUME CS:CODE,DS:DATA
MAIN: MOV AX,DATA
	  MOV DS,AX
	  MOV DX,OFFSET MES
	  MOV AH,9
	  INT 21H
	  MOV AH,4CH
	  INT 21H
CODE ENDS
	 END MAIN
	 
// MOV AH,4CH
   INT 21H 
这两句就代表返回DOS
```

#### 打印功能调用

- 5号功能调用：将DL中字符->打印机

```assembly
TEXT DB OCH, 'Good morning!', ODH,OAH,'$'
	 MOV BX, 0
	 MOV AH, 5
NEXT: MOV AL, TEXT[BX]
	  CMP DL, '$'
	  JE STOP
	  INT 21H
	  INC BX
	  JMP NEXT
STOP: ......

OCH:换页
ODH：回车
OAH：换行
```

#### 设置日期和时间

- **2BH** 功能调用：设置日期
  - 入口：CX/DH/DL：年/月/日
  - 出口：AL=0/0FFH：有效/无效
- **2AH** 功能调用：取得日期
  - 入口：无
  - 出口：CX/DH/DL：年/月/日
- **2DH** 功能调用：设置时间
  - 入口：CH/CL/DH/DL：时/分/秒/秒%
  - 出口：AL=0/0FFH：有效/无效
- **2CH** 功能调用：取得时间
  - 入口：无
  - 出口：CH/CL/DH/DL：时/分/秒/秒%

#### 异步通讯

- 3号功能调用：异步通讯输入
  - 出口：AL=输入数据
- 4号功能调用：异步通讯输出
  - 入口：DL=输出数据

### 程序设计方法

- 高质量程序的特点
  - 程序结构模块化
  - 运行速度少
  - 占内存空间少
- 汇编语言源程序设计步骤
  - 分析问题：建模，确定算法
  - 绘制流程图：由粗到细
  - 资源分配
  - 编写程序
  - 检查调试
  - 允许分析
- 程序的基本结构
  - 顺序结构
  - 分支结构
  - 循环结构
  - 子程序结构

#### 顺序结构

- 查表程序：内存中TAB开始存放0~9的平方值，通过人机对话，查给定数X的平方值，存入AL中

![image-20220802173542902](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208021736606.png)

```assembly
DATA SEGMENT
	 TAB DB 0,1,4,9,16,25,36,49,64,81
	 BUF DB 'Please input one number(0~9):',0DH,0AH,'$'
DATA ENDS
STACK SEGMENT STACK 'STACK'
		DB 50 DUP(?) ;	定义50字节的堆栈区
	TOP LABLE WORD 	 ;  栈底别名为TOP，类型为字
STACK ENDS
CODE SEGMENT
 MAIN PROC FAR
	 ASSUME CS:CODE, DA:DATA, SS:STACK
START: MOV AX,DATA
	   MOV DS,AX		;段初始化
	   MOV AX,STACK
	   MOV SS,AX
	   MOV SP,OFFSET TOP;栈指针
	   MOV BX,OFFSET TAB;表头
NEXT:  MOV DX OFFSET BUF
	   MOV AH,9			;9号功能调用，显示字符串
	   INT 21H			;提示输入一个数
	   MOV AH,1			;1号功能调用，输入一个字符
	   INT 21H			;扫描键盘，键值->AL
	   MOV AH,0
	   AND AL,OFH		;形成偏移量->AX
	   ADD BX,AX		;查表
	   MOV AL,[BX]		;存结果
	   RET
 MAINENDP
CODE ENDS
	 END START
```

#### 分支结构

- 统计BUF为首得字符串中数字，字母及其他符号的个数（单分支程序）
- 数字：0~9，ASCII码：30H~39H
- 字母：A~Z，ASCII码，41H~5AH

```assembly
DATA SEGMENT
	BUF DB N
		DB 01H,38H,47H,60H,......,76H
	NUM DB 3 DUP(?) ;存结果
DATA  ENDS
CODE  SEGMENT
MAIN  PROC FAR
	  ASSUME CS:CODE,DS:DATA
START:PUSH DS
	  SUB AX,AX
	  PUSH AX
	  MOV AX,DATA
	  MOV DS,AX
	  MOV CH, N 	;CH<-串个数
	  MOV BX,1		
	  MOV DX,0		;数字，字母个数
LP:	  MOV AH,BUF[BX];取字符
	  CMP AH,30H
	  JL NEXT   	;< '0'，转
	  CMP AH,39H
	  JG ABC		;>'9'，转
	  INC DH		;数字个数+1
	  JMP NEXT
ABC:CMP AH,41H
	  JL NEXT		;< 'A'，转
	  CMP AH,5AH
	  JG NEXT		;> 'Z'，转
	  INC DL		;字母个数+1
NEXT: INC BX		;地址+1
	  DEC CH		;个数-1
	  JNE LP
	  MOV BUF[BX],DH
	  MOV BUF[BX+1],DL
	  MOV AH,N
	  SUB AH,DH
	  SUB AH,DL
	  MOV BUF[BX+2],AH
	  RET
MAIN  ENDP
CODE  ENDS
	  END START
```

- 多分支程序1：有8个加工子程序，入口地址分别为：P0，P1，P2，...P7，根据键盘输入命令，依次转向8个子程序

```assembly
MOV AH,1
INT 21H		;1号功能调用，键值->AL
CMP AL, '0'
JE P0
CMP AL, '1'
JE P1
......
CMP AL, '7'
JE P7
......
```

- 多分支程序2：跳转表实现多分支之一
  - 根据表内地址分支，元素在表中的地址，即：表地址=表首址+偏移量

![image-20220802173636853](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208021736430.png)

```assembly
DATA SEGMENT
	BASE DW P0,P1,P2,P3,P4,P5,P6,P7
DATA ENDS
	......
MOV AH, 1
INT 21H			;AL<-键值
AND AL,OFH
MOV BX,OFFSET BASE ;BX<-表首址
MOV AH,0
ADD AL,AL		;形成偏移量，偏移量=键值*2
ADD BX,AX		;表地址
JMP WORD PTR [BX];转入口地址
	......
```

- 多分支程序3：根据表内指令分支

![image-20220802174855601](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208021749322.png)

```assembly
DATA SEGMENT
BASE DB E9,P0L,P0H,E9,P1L,P1H,......
DATA ENDS
	......
	 MOV AH, 1
	 INT 21H
	 AND AL, OFH
	 MOV BL, AL
	 ADD AL, AL
	 ADD AL, BL			 ;偏移量=键值*3
	 MOV AH, 0
	 MOV BX, OFFSET BASE ;表首址
	 ADD BX, AX			 ;表地址
	 JMP BX				 ;跳入表内，执行转移指令
```

#### 循环结构

![image-20220803143220089](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208031432587.png)

- 十六进制数->ASCII（先循环后判断）
  - 将BX中的16进制数转换为ASCII，存放到BUF开始的单元中，并显示出来

```assembly
	 MOV SI, OFFSET BUF
	 MOV CH, 4
NEXT:MOV CL, 4
	 ROL BX, CL		;最高4位移右边
	 MOV AL, BL
	 AND AL, 0FH
	 ADD AL, 30H
	 CMP AL, 3AH
	 JL  STORE 		;0~9,转
	 ADD AL, 7		;A~F,+7
STORE:MOV [SI], AL
	  MOV AH, 2
	  MOV DL, AL
	  INT 21H
	  INC SI
	  DEC SH
	  JNZ NEXT
	  HLT
```

- 统计1的个数
  - AX寄存器中有一个16位二进制数，统计其中1的个数，并存入CL中

```assembly
	MOV CL, 0
L1: AND AX, AX
	JZ STOP
	SAL AX, 1
	JNC L1
	INC CL
L2: JMP L1
STOP: HLT
```

- 多重循环（冒泡法）
  - 给BUF开始的数组从小到大的顺序排序
  - 编程思路:从第一个数开始,顺序比较相邻两数,若顺序不对,则交换位置,第一遍比较N-1次,最大数沉到数尾;第二遍只需比较N-2次;共进行N-1遍即可完成排序。若设置交换标志，可加快进程。

```assembly
START: MOV DI, OFFSET BUF
	   MOV CX, [DI]
	   DEC CX		 	;内循环次数=N-1
   L1: MOV DX, CX	 	;DX=外循环次数
   	   MOV BH, 0	 	;交换标志
   L2: ADD DI, 2	 	;指向下一个字
       MOV AX, [DI]
       CMP AX, [DI+2]	;相邻两数比较
       JBE CONTI	 	;Xi<=Xi+1,不交换
       XCHG AX, [DI+2]	;Xi>Xi+1,交换
       MOV [DI], AX
       MOV BH, 1	 	;交换标志置1
COUTI: LOOP L2
	   CMP BH, 0
	   JE STOP		 	;未交换,结束
	   MOV CX, DX		
	   MOV DI, OFFSET BUF
	   LOOP L1			;CX-1,DX-1
 STOP: RET
```

#### 子程序结构

- 子程序（过程）调用应处理好三个问题：
  - 保护断点：CS,IP入栈（CPU自动完成）
  - 保护现场：子程序用到且与主程序有冲突的寄存器或存储单元需保护
  - 参数传递
    - 寄存器传递
    - 存储器传递
    - 堆栈传递
- BCD码->二进制

```assembly
;名称：BCD2BIN
;功能：将一个字节BCD码转换成二进制
;使用寄存器：CX
;入口参数：AL存放两位BCD码
;出口参数：AL存放二进制码
;调用其他子程序：无

BCD2BIN PROC FAR
	PUSH CX
	MOV CH, AL
	AND CH, OFH
	MOV CL, 4
	SHR AL, CL
	MOV CL, 10
	MUL CL
	ADD AL, CH
	POP CX
	RET
BCD2BIN ENDP
```

- 求二进制数组之和

```assembly
数据段定义两个数组，分别求两个数组元素之和（不计溢出）

SUM PROC NEAR		;求和子程序
	XOR AX AX
L1: ADD AX, WORD PTR[SI]
	INC SI
	INC SI
	LOOP
	MOV WORD PTR[SI], AX
	RET
SUM ENDP
	
MAIN PROC FAR		;主程序
START: ......
	   ......
	   LEA SI,ARY1
	   MOV CX, LENGTH ARY1
	   CALL SUM
	   LEA SI,ARY2
	   MOV CX, LENGTH ARY2
	   CALL SUM
	   RET
MAIN ENDP
```

### 宏汇编与条件汇编

#### 宏汇编

> 独立程序段，定义后可被调用，与子程序相似

- 宏定义
  - ![image-20220804103104634](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041759924.png)

- 宏调用

```assembly
宏名 [实际参数1, 实参2, ......]
```

- 宏展开
  - 汇编时对每个宏展开
    - 宏体取代宏名
    - 实元取代哑元
    - 展开部分前带"+"号

将AL中内容右移4次

```assembly
SHIFT MACRO
	  MOV CL, 4
	  SAR AL, CL
	  ENDM

宏调用: SHIFT
宏展开: + MOV CL, 4
	   + SAR AL, CL	   
```

将AL中内容右移任意次

```assembly
SHIFT MACRO N
	  MOV CL, N
	  SAR AL, CL
	  ENDM

宏调用: SHIFT 7 
```

将任意寄存器内右移任意次

```assembly
SHIFT MACRO N,M
	  MOV CL, N
	  SAR M, CL
	  ENDM

宏调用: SHIFT 7, AL
	   SHIFT 2, DH
```

对任意寄存器左移或右移任意次

```assembly
SHIFT MACRO N,M,P
	  MOV CL, N
	  S&P M, CL
	  ENDM
	  
宏调用: SHIFT 7, AL, HR
	   SHIFT 4, BH, AL
```

显示回车换行

```assembly
CRL MACRO		 ;建立宏
	MOV DL, 0DH	 ;回车的ASCII
	MOV AH, 02H
	INT 21H
	MOV DL, 01H	 ;光标移到第一列
	MOV AH, 02H  ;换行的ASCII
	INT 21H		 ;光标移到下一行
ENDM
```

#### 宏与子程序的区别

- 宏执行速度快
  - 子程序CALL/RET需入栈/出栈操作
- 宏使用灵活
  - 子程序仅入口参数可变，而宏的哑元形式多样
- 宏占内存多
  - 子程序只占一段空间；宏调用多少次，就插入/展开多少次

## 存储器

### 存储器分类

- 按其在计算机中的地位和作用分为两大类
  - 内存
    - 主存储器，位于主机内部
    - 存放当前或经常使用的程序/数据
    - CPU可直接访问，速度快
    - 半导体器件构成，价格高
    - 容量有限(8086：2<sup>20</sup>=1MB; 80386/486：2<sup>32</sup>=4GB; Pentium：2<sup>36</sup>=64GB)
  - 外存
    - 辅助存储器，主机外部
    - 存放大量/长期保存的数据(`软盘/硬盘/光盘/磁带...`)
    - 海量,速度慢
    - 磁表面存储器，需专用驱动设备(`硬驱/软驱/光驱...`)
    - 新型：固态硬盘(SSD)，无需盘片和磁头，速度快

![image-20220804151421834](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041514426.png)

- **半导体存储器按功能/性质分为两大类**

  - **RAM**(随机存取存储器)：随机读/写，断电丢失
    - `SRAM`(静态RAM)
      - 速度快(<10ns)
      - 稳定，不用刷新
      - 结构复杂(6管)，容量小，功耗大
      - 只要有电源加于触发器，数据即可长期保留
    - `DRAM`(动态RAM)
      - 高密度(单管，电容)
      - 低功耗，低价格
      - 速度低(50ns)，需刷新电路
    - ![image-20220804160231906](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041706776.png)
  
  - **ROM**(只读存储器)：只能读出，断电保护，非易失性存储器
    - `ROM`：永不更改，适用于大批量生产
    - `PROM`：熔丝工艺，一次写入，不能更改（可编程的只读存储器，只允许被写入一次）
    - `EPROM`：紫外线擦除，可多次擦写（可擦可编程的存储器，但擦除需要紫外线照射）
    - `EEPROM`：电擦写(按字节/位)，使用方便（电可擦可编程的只读存储器，可用电信号擦除和写入）
    - `Flash ROM`：闪速存储器(按扇区/块)，使用方便（EEPROM改良，必须按块擦除，被广泛用于PC的主板上，用来保存BIOS程序，便于程序升级）
  - 存储器性能指标
    - 存取时间、功耗、可靠性


### 存储器的结构与工作原理

#### 存储器的结构与生成

- 存储器的结构与生成
  - 存储体：
    - 存储器芯片的主要部分，用来存储信息
  - 地址译码电路：
    - 根据输入的地址编码来选中芯片内某个特定的存储单元
  - 片选和读写控制逻辑：
    - 选中存储芯片，控制读写操作

![image-20220804165709442](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041706511.png)

- 地址译码电路

![image-20220804170611365](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041706461.png)

#### 存储器的组成与原理

- 常用芯片
  - RAM：`6116`/`6264`/`62128`/`62256`
  - EPROM：`2716`/`2732`/`2764`/`27128`/`27256`/`27512`
  - 每个芯片的容量从第2位开始到最后的数字/8得到的K数，如512/8=64K，则27512芯片的容量就是64K*8，其他的芯片都一样
- SRAM芯片**6264**
  - 存储容量：8K*8
  - 28个引脚：
    - 13根地址线A12~A0
    - 8根数据线D7~D0
    - 片选CS1*、CS2
    - 读写OE\*(READ)、WE*(WRITE)

![image-20220804172126943](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041743883.png)

- EPROM芯片**2716**
  - 存储容量位2K*8
  - 24个引脚
    - 11根引脚线A10~A0
    - 8根数据线D07~D00
    - 片选/编程CE*/PGM
    - 读写OE*
    - 编程电压VPP

![image-20220804174312652](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041744921.png)

- EPROM芯片**2764**
  - 存储容量为8K*8
  - 28个引脚：
    - 13根地址线A12~A0
    - 8根地址线D8~D0
    - 片选CE*
    - 编程PGM*
    - 读写OE*
    - 编程电压VPP

![image-20220804174509857](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208041745198.png)

### 存储器与CPU连接

- 连接方法

  - 基本方法
    - 三总线对应相连
      - 片选线、地址线、数据线、控制线
      - ![image-20220805095541498](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208050955612.png)

  - 注意事项
    - CPU总线负载能力
    - 时序的配合
    - 容量扩展与地址分配
    - 控制信号的连接

#### 数据线的连接

- 若存储器芯片的数据线为16条，则：

  - 存储器16数据线与CPU的16位数据总线直接相连

- 若存储器芯片的数据线位8条，则：

  - 存储器的8位数据线与CPU的低8位数据线相连

  - 两个存储器芯片为1组，与CPU的16为数据线相连

    - ![image-20220805100057230](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051001046.png)

    - 两个存储芯片的数据线分别连接于CPU数据总线的高、低8位

    - 这些芯片应被看作是一个整体，称为"芯片组"

#### 地址线的连接

- 芯片地址线通常全部与CPU的低位地址总线相连
- 寻址时，这部分地址的译码是在存储芯片内完成的，称为"片内译码"
- 片内译码是全是0~全是1

![image-20220805100443017](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051004077.png)

**片选段的连接**

##### **线选法**

> 每根高位地址线负责选中一个芯片(组)线选法
>
> 构成简单，但地址空间浪费，地址重叠

- ![image-20220805105853964](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051058194.png)

- | 2764 | A19 18 17 16 15 | A14 A13 | A12~A0  | 地址范围      |
  | ---- | --------------- | ------- | ------- | ------------- |
  | (1)  | xxxxx           | 1   0   | 全0~全1 | 04000H~05FFFH |
  | (2)  | xxxxx           | 0   1   | 全0~全1 | 02000H~03FFFH |

- 通过CPUA12~A0传输给两个芯片中的某一个，需要A13和A14控制两个芯片的的开关进行传输，A14和A13中0为选中的，1为关闭的

- **如何判断芯片的地址范围**：

  - A19\~15没有使用，就默认为0，首先A14为1，A13为0
  - A12~0时是片内译码所以是13个0到13个1，同时又是4位一分，就是`0 0000 0000 0000`~`1 1111 1111 1111`
  - 再前面在加上A19~15和A14、A13的值，分别是`0000 010`，
  - 加入到里面就是`0000 0100 0000 0000 0000`~`0000 0101 1111 1111 1111`，
  - `0100`就是16进制的4，前面4位全是0就写0，后面全是0就写000，最后就是`04000H`，
  - `0101`就是16进制的5，前面4位全是0就写0，后面全是1就写FFF，最后就是`05FFFH`，
  - 则它的地址范围就是`04000H~05FFFH`

##### **译码法**

> 部分译码：高位地址线中的某几位参与译码，也存在地址重叠浪费空间的问题；
>
> 全译码：全部高位地址线均参与译码，每个存储单元的地址都是唯一的，不存在地址重叠

![image-20220805110340794](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051103115.png)

- 部分译码

  - 4个2732的芯片，4k*8的容量

  - 判断芯片的地址范围，和线选法没有什么太大的差别，仅仅只是一点细微的小区别

    - A19~17没有使用，就默认为0，

      - 首先说第一个芯片的地址范围，则A14、13、12都为0
      - 同时A16和A15，A16对应G1，G1必须是高电平，则A16为1，A15为0
      - 同时又是4位一分，就是A11\~A0十二位：`0000 0000 0000`~`1111 1111 1111`
      - 再前面在加上A19~17和A16、A15、A14/13/12的值，分别是`0001 0000`，
      - 加入到里面就是`0001 0000 0000 0000 0000`~`0001 0000 1111 1111 1111`，
      - `0001`就是16进制的1，后面全是0就写000，最后就是`01000H`，
      - `0001`就是16进制的1，后面有0就写0，有1则写1就写FFF，最后就是`010FFFH`，
      - 则它的地址范围就是`1000H~10FFFH`

    - ---

    - 如果是第2个芯片使用的话，则要把Y1为0，则A12就为1，其他不变

      - 就是`0001 0001 0000 0000 0000`~`0001 0001 1111 1111 1111`，
      - 最后地址为：`11000H`~`11FFFH`

    - ---

    - 如果是第3个芯片使用的话，则就是要把Y2为0，则就是A13为1，A12=0，其他不变

      - 就是`0001 0010 0000 0000 0000`~`0001 0010 1111 1111 1111`，
      - 最后地址为：`12000H`~`12FFFH`

    - ---

    - 如果是第4个芯片使用的话，则就是要把Y3为0，则就是A13为1和A12=1，其他不变

      - 就是`0001 0011 0000 0000 0000`~`0001 0011 1111 1111 1111`，
      - 最后地址为：`13000H`~`13FFFH`

- 全部译码

  - ![image-20220805152459977](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051525237.png)

  - 和上面的的部分译码的获取芯片的线路的地址一样
  - 地址范围：`1C000H~1FFFFH`

### 存储器的拓展

#### 位拓展

- 使用8K\*1的SRAM芯片组成的8K\*8的存储器
- #CS连在一起，#WE连在一起，地址线连接在一起，数据线：每个芯片单做作一位

```assembly
要组成8K*8的存储器，但是只有8K*1的芯片，计算
8K*8 / 8K*1=8片
使用8片8K*1的芯片
算出地址线，8K=2^13(2的13次方)，就是A0~A12
数据线则是8片需要8个，D0~D7
然后CS和WE连接在一起
```

![image-20220831094044130](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208310941348.png)

#### 字拓展

- 使用2K\*8的SRAM芯片组成8K\*8的存储器
- #CS与译码器相连，#WE连在一起，地址线连在一起，数据线：每个芯片单独做一位

```
要组成8K*8的存储器，但是只有8K*1的芯片，计算
8K*8 / 2K*8 = => 4K*1=4片
使用4片2K*8的芯片
数据线则是需要8位，D0~D7
算出地址线，2K=2^11(2的13次方)，就是A0~A10
同时需要组成8K*8，2的13次方就是8K，A11和A2，使用2-4译码器
```

![image-20220831100816794](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208311053012.png)

#### 字位拓展

- 使用2K\*4的SRAM芯片组成2K\*8的存储器

```
要组成8K*8的存储器，但是只有2K*4的芯片，计算
8K*8 / 2K*4 => 4*2=8片
使用8片2K*4的芯片
使用两片一组，分为四组
每一片芯片都是4位，但是需要8条数据线，每一组上面的芯片连接低四位，下面的芯片连接高四位
2K的地址线则是2的11次方，需要A0~A10等11根地址线，同时要组成8K，所以需要A11~A12连接译码器
```

![image-20220831105614009](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208311056942.png)

## I/O接口

### I/O接口的作用

> I/O接口是位于系统与外设间、用来协助完成数据传输和控制（通信）任务的逻辑电路

- 什么是输入/输出(I/O)
  - 主机与外界交换信息称为输入/输出
- 外设为什么不能直接与总线连接？
  - 外设相对于CPU速度很慢，并且外设的信号形式、数据格式也各不相同
- 什么是接口？
  - 介于主机和外设之间的一中缓冲电路
- 接口的作用
  - 使总线与外设隔离，协调主机与外设间数据传送速度不匹配的矛盾
  - 为主机提供外设工作状态信息及传送主机给外设的控制命令
  - 对信息的传送形式进行变换
- CPU与外设交换的信息
  - 数据信息、状态信息、控制信息

#### 为何采用I/O接口

- ![image-20220805165711313](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051657751.png)

- 接口电路解决了高速CPU与低速外设的不匹配问题
  - 速度不匹配
  - 信号电平不匹配
  - 信号格式不匹配
  - 时序不匹配

- 类型各异的I/O设备
  - 工作原理不同
    - 电子、机电、机械、电磁、...
  - 信息类型多种
    - 模拟量、数字量、开关量、脉冲量
  - 传输 速度有别
  - 传送方式不同
    - 串行、并行
  - 编码格式多样
    - 二进制、BCD码、ASCII码、...

#### 接口电路的功能

- 实现缓冲、锁存：输入要缓冲，输出要锁存
  - 输入接口的缓冲环节
    - ![image-20220805172149322](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051748168.png)
  - 输出接口的锁存、缓冲环节
    - ![image-20220805172424029](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051748093.png)

- 联络：握手，应答，工作状态联络(Ready、Busy)
  - 数据格式的变换：
    - 电压/电流变换
    - 串行/并行变换
    - 电平/电平变换
    - A/D、D/A变换

- 进行地址译码：I/O寻址，选中工作端口和设备选择

- 传送控制命令和状态信息

- 接口基本结构
  - ![image-20220831112514438](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208311125554.png)


### I/O端口及其寻址方式

#### I/O端口

CPU与外设间交换的信息包括

- 数据
  - 通过数据口(数据寄存器)传送
- 状态
  - 通过状态口提供外设状态，共CPU测试、联络等(`Ready`/`Busy`/`Error`)
- 命令
  - 通过控制口接受CPU发送的各种控制信号

![image-20220805174832109](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208051759387.png)

 #### I/O端口编址方式

- I/O单独编制
  - 如8086/8088、Z80等
  - 优点
    - 存储空间不受I/O端口地址空间影响，由`M/IO`区分，存储空间单独划分
  - 缺点
    - 需专用I/O指令增加了指令系统的复杂性
  - ![image-20220805175905877](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208080956846.png)
- I/O与存储器统一编址
  - 存储器映象方式
  - 如：MC6800、68HC05
  - 优点
    - 对I/O端口的操作如同对存储单元操作一样，无需专门的I/O指令
  - 缺点
    - 占用了一部分存储器空间
  - ![image-20220805175947530](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208080957788.png)

### 常用I/O接口芯片

#### 简单I/O芯片

- 简单I/O接口芯片

  - 74LS244/245：数据缓冲器

  - 74LS273/373：数据锁存器

- 数据缓存器：74LS244
  - 单向、三态
  - ![image-20220808102016608](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081026615.png)

- 数据缓存器：74LS245
  - 双向、三态
  - 高电平时数据从左到右，低电平时数据从右到左
  - ![image-20220808102240213](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081026974.png)

- 数据锁存器：74LS373
  - ![image-20220808103736898](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081037788.png)

#### 可编程I/O接口芯片

- 可以通过程序改变芯片的功能
- 8255：可编程并行接口芯片
- 8251：可编程串行接口芯片
- 8253：可编程定时/计数器
- 8259：可编程中断控制器
- 8237：可编程DMA控制器
- PSD：现场可编程外围接口芯片
  - 集成了端口、锁存器、可编程地址译码(PAD)、ERROR和SRAM以及电源管理、中断控制、定时器等功能部件
  - 两片方案：MCU/DSP/ARM+CPLD/FPGA

### CPU与外设间传送数据的方式

> 程序控制I/O方式
>
> 中断方式
>
> DMA方式

#### 程序控制I/O方式

##### 无条件传送方式

- CPU对外设进行输入输出时无需考虑外设的状态

- 需要传送时，执行IN/OUT指令即可

- 适用于无需应答联络的场合

- 简单输入口，将开关状态->CPU
  - ![image-20220808112358059](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081542522.png)


- 简单输出口：控制LED发光
  - ![image-20220808112358059](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081543789.png)

##### 条件传送/查询方式

- 在输入/输出前，CPU查询外设的状态，当外设处于准备好状态/输出设备处于空闲状态，CPU才进行输入/输出

![image-20220808152914050](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081543358.png)

- 查询方式：打印输出

```assembly
状态口：83H，D1(BUSY)=1/0:忙/闲
数据口：82H

	MOV CX, COUNT
LP: IN AL, 83H	  ;读PRT状态口
	TEXT AL, 02H  ;D1:BUSY
	JNZ LP		  ;查询状态位
	MOV AL, [BX] 
	OUT 82H, AL	  ;输出数据
	INC BX
	LOOP LP
```

- 查询方式(输入)
  - ![image-20220808161616098](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081616026.png)


- 查询方式(输出)
  - ![image-20220808161705429](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081617928.png)

#### 中断I/O方式

- 当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转去执行数据的输入/输出操作。数据传送结束后，CPU再继续执行被暂停的程序

![image-20220808170735368](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081707383.png)

- 中断与查询方式的比较
  - 查询：CPU主动查询外设状态，CPU处于主动状态，而外设处于被动状态，等待费时
  - 中断：右外设主动向CPU发出请求等CPU处理，在没有发出请求时，CPU和外设都可以独立进行各自的工作，外设准备好才向CPU请求中断，CPU效率高

![image-20220808170811562](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081708672.png)

#### DMA方式(直接存储器存取方式)

> 无需CPU干预
>
> 适用于大量、高速的数据块传送

- DMA方式是存储器和外设之间、存储器和存储器之间进行数据传送，传送过程无需CPU介入

![image-20220808172413046](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081724040.png)

- DMA传送得工作过程
  - CPU对DMA控制器进行初始化设置
  - 外设、DMAC和CPU三者通过应答信号建立联系：CPU将总线交给DMAC控制
  - DMA传送
    - DMA读存储器：存储器 -> 外设
    - DMA写存储器：存储器 <- 外设
  - 自动增减地址和计数，判断传送完成否
- DMA与中断方式得比较
  - 中断方式传送的不足
    - 外设->CPU->存储器
    - 外车<-CPU<-存储器
  - 直接存储器存取DMA
    - CPU释放总线，由DMA控制器管理
    - 外设->存储器
    - 外设<-存储器

### PC机I/O译码电路及地址分配

![image-20220808175843378](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208090907688.png)

| 分类   | 地址范围(H)    | I/O设备(端口)        |
| ------ | -------------- | -------------------- |
| 系统板 | 000~01F(00~0F) | 8237A-5 DMA控制器    |
| 系统板 | 020~03F(20~21) | 8259A 中断控制器     |
| 系统板 | 040~05F(40~43) | 8253-5 计数器/定时器 |
| 系统板 | 060~07F(60~63) | 8255A-5 并行接口     |
| 系统板 | 080~09F(80~83) | DMA页寄存器          |
| 系统板 | 0A0~0BF(A0)    | NMI屏蔽寄存器        |
| 系统板 | 0C0~0DF        | 保留                 |
| 系统板 | 0E0~0FF        | 保留                 |

| 分类    | 地址范围(H) | I/O设备(端口)     |
| ------- | ----------- | ----------------- |
| I/O通用 | 200~20F     | 游戏I/O           |
| I/O通用 | 2F8~2FF     | 异步通信2(COM 2)  |
| I/O通用 | 300~31F     | 实验卡(原型卡)    |
| I/O通用 | 320~32F     | 硬磁盘适配器      |
| I/O通用 | 378~37F     | 并行打印接口      |
| I/O通用 | 380~38F     | 同步通信控制器    |
| I/O通用 | 3B0~3BF     | 单显/打印机适配器 |
| I/O通用 | 3F0~3F7     | 软磁盘适配器      |
| I/O通用 | 3F8~3FF     | 异步通信1(COM 1)  |

## 中断系统

### 中断的概念

#### 中断概述

*CPU在正常执行程序时，被内部或外部的事件所打断，转去执行一段预先安排好的<u>中断服务程序</u>；服务结束后，又返回原来的<u>断点</u>，继续执行原来的程序，这一过程称为”中断“。*

![image-20220809093424081](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208090937444.png)

#### 中断的作用与特点

![image-20220808170811562](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208081708672.png)

- 中断解决了高速CPU与低速外设速度上的矛盾
  - 查询
    - CPU需花费大量时间查询等待；
    - 当系统中有多个外设时，不具备实时性；
    - 实现简单
  - 中断
    - 外设准备就绪，会主动向CPU发出请求
    - CPU与外设大部分工作并行工作，效率高
    - 适用于实时控制、处理突发/紧急事件等

#### 中断源分类和中断类型

![image-20220809105516875](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091055992.png)

- 外部中断
  - 非屏蔽中断(NMI)
    - 由NMI引入
    - 不能由软件禁止
    - 中断类型号2
  - 可屏蔽中断(INTR)
    - 由INTR引入*高电平*，维持到响应中断
    - 可由软件控制：STI/CLI，IF=1/0 允许/禁止
    - 常通过8259A(可编程中断控制器)与CPU连接

- 内部中断：<sub>软件中断(不可屏蔽)</sub>
  - INT n，运算错(除法0，溢出4)，单步1，断电3

#### 中断类型

- 在CPU执行8086/8088CPU可以处理256种不同类型的中断，每一种中断都给定一个编号(0~255) ,称为中断类型号，CPU根据中断类型号来识别不同的中断源。

#### 中断向量表

- 中断向量表是存放中断向量的一个特定的内存区域。所谓中断向量，就是中断服务程序的入口地址。对于8086/8088系统，所有中断服务程序的入口地址都存放在中断向量表中。
- 每种中断对应一个中断类型号，每个中断类型号与一个中断服务程序的入口地址相对应。每个中断服务程序的入口地址占4个存储单元，其中低地的两个单元存放中断服务程序入口地址的偏移量（IP) ;高地址的两个单元存放中断服务程序入口地址的段地址(CS)。
- 256个中断向量要占256x4=1024个单元，即中断向量表长度为1K个单元。
  8086/8088系统的中断向量表位于内存的前1K字节，地址范围为0000H ~003FFH。

![image-20220809105658980](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091458447.png)

将每个中断源中断入口地址依次排列存放，形成一个入口地址表——中断向量表CPU根据中断类型号n->n*4->从表中查找入口地址->跳转至服务程序

```assembly
中断类型号n=44H，中断服务程序，入口地址位3600H:2000H

画出其在中断向量表中的位置

0110H |00| IP(低8位在前，高8位在后)
	  |20|
0112H |00| CS(低8位在前，高8位在后)
	  |36|
```

```assembly
已知中断向量表中(0040H)=240BH，(0042H)=D169H

确定型号n及中断服务程序的入口地址

0040H |0B|
	  |42|
0042H |69|
	  |D1|

型号n：
	40H/4，相当于右移两位，
	0100 0000右移两位，0001 0000
	就是10H
中断服务的入口地址：
	D169H:240B
如果是物理地址的话就是段地址左移4位，加偏移地址
```

#### 中断优先级

- 中断优先级
  - 按请求中断事件的轻重缓急，预先排好优先顺序，又称中断优先权。
  - 当多个中断源同时申请中断时，CPU按优先级由高到低的次序依次响应
- 8086CPU响应中断的优先顺序：
  - 内部中断->NMI(非屏蔽)->INTR(可屏蔽)->单步中断高优先级中断可打断低优先级中断过程，实现中断嵌套；反之不然。

#### 中断嵌套

![image-20220809144807218](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091458406.png)

优先顺序：3<sup>#</sup> > 2<sup>#</sup> > 1<sup>#</sup>

嵌套深度无规定，但受堆栈限制

#### 中断屏蔽

通过软件设置：IF=0

使CPU不响应外设的中断请求

#### 中断源的识别

当有多个外设同时申请中断时，CPU应如何识别

- 软件查询法
  - ![image-20220809150306600](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091534030.png)

  - 结构查询顺序即为优先顺序，结构简单，但速度慢

- 向量中断法————中断向量表

  - 对所有中断请求响应速度一样

### 中断处理过程

#### 中断处理过程

`中断请求->中断响应->保护断点->中断处理->中断返回`

- 中断服务程序
  - ![image-20220901092844851](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209241534208.png)

- 中断服务程序入口地址
  - 在中断向量表中的位置可由“`中断类型号*4`”计算出来

- 中断请求
  - CPU在指令最后一个T状态检测INTR，若有请求且CPU允许、外设未屏蔽，则当前指令执行完成后响应中断
- 中断响应
  - CPU向外设发INTR，外设收到后，向DB送中断类型号n；此后，CPU
    - 从DB获取n
    - FLAGS入栈,清IF,TF
    - CS,IP入栈，保护断点
    - n*4查矢量表,取出入口地址并转向终端服务程序
- 中断服务
  - 保护现场，执行中断服务程序
- 中断返回
  - 恢复现场，IP,CS,FLAGS依次出栈，中断返回

#### 中断处理时序

![image-20220809153449588](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091610818.png)

- INTR引脚出现>2T<sub>时钟</sub>的高电平
- CPU发出两个INTR回答信号
- 第一个INTA->8259A，表示CPU接受请求并禁止其他请求
- 8259A收到第二个INTA后，送n->DB低8位
- CPU从DB读取n，n*4->查矢量表->取入口地址->转服务程序

可屏蔽中断响应和处理过程

![image-20220809155537751](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091610829.png)

8086中断响应和处理流程

![image-20220809155833249](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208091611093.png)

### 8259A——可编程中断控制器

- 什么是8259A
  - 8259A是可编程中断控制器(Programmable Interrupt Controller)芯片，用于管理和控制80x86的外部中断请求，可实现中断优先级判定，提供中断类型号，屏蔽中断输入等功能。单片8259A可管理8级中断，若采用级联方式，最多可以用9片8259A构成两级中断机构，管理64级中断。
- 8259A内部结构
  - 中断请求寄存器(IRR)、中断屏蔽寄存器(IMR)、中断服务寄存器(ISR)、优先权判别器(PR)
- 8259A的编程
  - 初始化命令字：ICW<sub>1</sub>、ICW<sub>2</sub>、ICW<sub>3</sub>、ICW<sub>4</sub>
  - 操作命令字：
    - OCW<sub>1</sub>
      - ![image-20220901093414015](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209241534646.png)
    - OCW<sub>2</sub>、OCW<sub>3</sub>

- 主要功能
  - 具有8级优先级控制，可级联扩展至64级
  - 每一级中断可由程序单独屏蔽/允许
  - 可提供中断类型号n->CPU
  - 可编程选择多种工作方式

```
已知CS=4060H，IP=0280H，SS=0500H，SP=00A0H，FLAGS=0695H，(00018H)=2030H，(0001AH)=3A80H

执行当前指令INT6后程序转向何处？堆栈有何变化

1.程序转向何处？
当前指令指针就是CS、IP，始终指向下一条执行的地址
INT 6所在的地址，就是CS(4060段地址)、IP(0280偏移地址)
程序转向何处，就是n*4=24,16进制的18H，
那么就是
00018H |30| IP(偏移地址)
00019H |20|
0001AH |80| CS(段地址)
0001BH |3A|
连续4个字节，存放着中断服务程序的入口地址，也就是要转的地方，程序最终转向3A80 2030

2.堆栈有何变化
先压FLAGS，再压代码段(CS)，再压偏移地址(IP)，最后偏移地址指向的是下一条，所以+2
9A-> 	|82|
        |02|
        |60|
		|40|
9F->	|95|
A0-SP-> |06|

3.FLAGS中那些位有变化
IF、TF被清零了
```

## 可编程并行接口芯片8255A

### 内部结构与工作原理

#### 结构与功能

![image-20220809165712495](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101029996.png)

- 3个8位I/O口：A口，B口，C口

  - 端口内部含缓冲/锁存器

- 两组控制逻辑

  - A组：控制PA和PC<sub>7~4</sub>
  - B组：控制PB和PC<sub>3~0</sub>

- 读写控制

  - CS,RD,WR与A1,A0配合，完成对端口的操作

  - | A1 A0 | 端口   |
    | ----- | ------ |
    | 0  0  | A口    |
    | 0  1  | B口    |
    | 1  0  | C口    |
    | 1  1  | 控制口 |

- 关于8255硬件连接的一些说明

  - ![image-20220810090712020](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101029746.png)

#### 控制字

- 方式控制字
  - ![image-20220810090821380](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101029962.png)

- C口置位/复位控制字
  - ![image-20220810091858025](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101029032.png)

```assembly
从PC5引脚输出一正脉冲，设8255口地址：60H~63H
MOV AL, 00001011B ;PC5置1
OUT 63H, AL		  ;低电平变高电平
MOV AL, 00001010B ;PC5置0
OUT 63H, AL		  ;高电平转低电平
```

#### 工作方式

- **方式0**：基本I/O方式
  - 特点
    - 适用于不需应答联络的场合
    - 输出锁存，输入无锁存
    - PA,PB,PCA7~4,PC3~0可组成16种I/O方式

```assembly
MOV AL, 91H
OUT 63H, AL
```

- **方式1**：选通I/O方式
  - PA，PB口可分别工作于方式1，均可作输入/输出
  - 特点
    - PA,PB之一工作与方式1时，PC口就有3位需配合，此时，零一端口及PC口其他数据位可工作于方式0
    - 若PA,PB口均工作于方式1，PC口就有6位需与之配合，其余2位仍可作I/O
  - 方式1又分为：
    - 选通输入方式
      - ![image-20220810104721611](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101058305.png)
    - 选通输出方式
      - ![image-20220810105853199](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101059949.png)
    - 选通输入输出方式
      - ![image-20220810110033673](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101100023.png)

- 方式2：双线总线方式
  - 只有A口能工作于此方式，既能输出又输入，但不同时
  - A口工作与方式2时，B口可工作与方式0或方式1
    - PB方式0：PC2~0可作I/O
    - PB方式1：PC2,1,0作B口联络线
  - ![image-20220810110342440](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101105981.png)

#### 状态字

通过读取C口状态字，可测试或检查外设状态

- 方式1状态字

  - 输入状态字
    - ![image-20220810110617668](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101110343.png)

  - 输出状态字
    - ![image-20220810110637403](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101110291.png)

- 方式2状态字：
  - ![image-20220810110653496](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101110961.png)

### 简单应用

#### 基本I/O(1)

- 检测开关K0~7状态，并用LED0~7实时指示

![image-20220810110939446](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101525617.png)

```assembly
1. 确定8255端口地址
A口入，B口出
如果芯片想让8255A工作，则CS片选必须有效，则Y4必须有效，则分别给A4 3 0赋值1 0 0，A7为1，A6和A5因为是与非关系，则都是1，A2和A1是因为连接端口进行变动的，如果是00就是PA口，01为PB口，10为PC口，11为控制口
A7~A0为CPU地址线
A7 6 5 4 3 2 1 0
 1 1 1 1 0 0 0 0	PA口(F0H)
 1 1 1 1 0 0 1 0	PB口(F2H)
 1 1 1 1 0 1 0 0	PC口(F4H)
 1 1 1 1 0 1 1 0	控制口(F6H)
 
2.查询程序
	   MOV DX, 0F6H
	   MOV AL, 90H	  ;10010000(控制字),方式0,PA输入,PB输出
	   OUT DX, AL	  ;写控制字
TEST1：MOV DX 0F0H
	   IN AL, DX	  ;读A口开关状态
	   MOV DX, 0F2H
	   OUT DX, AL	  ;由B口输出
	   CALL DEALY	  ;延时
	   JMP TEST1	  ;循环回来
```

#### 基本I/O(2)

- 用数码管实时显示K3~K0的16种组合状态

![image-20220810152426931](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101525456.png)

```assembly
    MOV AL, 90H
    OUT 63H, AL
IN_PORTA:
    IN AL, 60H	;从A口读数据
    AND AL, 0FH	;将高四位清零
    MOV BX, OFFSET TAB
    XLAT
    OUT 61H, AL
    CALL DELAY
    JMP IN_PORTA

TAB:DB 40H,79H,24H,30H,19H,12H,02H,78H;段码表

	DB 00H,18H,08H,03H,43H,21H,06H,0EH
```

#### 键盘接口

- 键盘结构
- 编程要点
  - 确定是否有键按下
    - （置行线输出、列线输入方式）
    - 发行码：行线输出全0
    - 读列码：判断列线是否全1？否，则有键按下(延迟去抖动再次判断)
  - 确定键的位置
    - 逐行扫描法
      - 发行码：每次仅一次输出0（从第0行开始）
      - 读列码：判列线，若全1，则闭合键不在此行，如此逐行判断...
      - 获得键码：从B口读取行列值编码，即键码->AL
  - 确定键名
    - 将键码预先排列成表，通过获得的键码查表确定键名

- ![image-20220810170504527](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101705085.png)

```assembly
    MOV AL, 0
    MOV DX, PORT_A
    OUT DX, AL		;输出行码00H
WAIT_PRES:
	MOV DX, PORT_b
	IN AL, DX		;读列值->AL
	AND AL, 0FH		;仅保留低4位
	CMP AL, OFH		;判断是否全1
	JE WAIT_PRES	;无键，继续扫描
	MOV CX, 16EAH	;延时去抖动
DLY:LOOP DLY
	IN AL,DX		;再读列值->AL
	AND AL, 0FH		;仅保留低4位
	CMP AL, 0FH		;判断列是否全1
	JE WAIT_PRES	;无键，返回扫描
```

#### 多位数码显示

- ![image-20220810174322245](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208101743855.png)

## 可编程定时器/计数器8253

### 内部结构与工作原理

#### 概述

> 定时与计数是微机系统种经常使用的功能
>
> 实现定时与技术的方法有三种

- 软件法
  - 编写程序延时实现定时/计数
  - 特点：节省费用，灵活方便；但浪费CPU事件
- 硬件法
  - 采用硬件电路实现定时/计数
  - 特点：不占机时;不可程控调节，精度低
- 软硬结合
  - 采用8253等可编程定时/计数器
  - 特点：定时期间不占机时，程控调节定时事件，精度高

#### 结构与引脚

- 三个相同且独立的通道
- 每个通道有一个16位减法计数器
- 每个通道可设定6种工作方式

![image-20220811150124454](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111518733.png)

![image-20220811150255675](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111518544.png)

#### 两大功能：定时与计数

- 8253工作过程
  - 对CLK引脚上的脉冲按二进制或BCD格式计数。每来一个脉冲，内部计数器减1，减至0，从OUT端输出一个脉冲
    - 定时：对等间隔脉冲计数即可实现定时
      - 定时时间*计数次数
    - 计数：只计脉冲个数，可不等健哥
  - CLK引脚输入脉冲的频率
    - 8253：f<sub>CLK</sub> <= 2MHz
    - 8254：f<sub>CLK</sub> <= 5MHz~10MHz
  - 门控信号GATE
    - GATE
      - ![image-20220811151805471](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111519493.png)

#### 8253控制字

![image-20220811155457217](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111555329.png)

#### 初始化编程步骤

- 写控制字
  - 选择通道，工作方式，计数格式
- 写计数初值
  - 初值8位：OUT一次即可
  - 初值16位：OUT两次，先低后高位
- 计数初值的计算
  - 方式0：`计数初值=间隔宽度/频率周期-1`
  - 其余：`计数初值=间隔宽度/频率周期`


```assembly
例：设8253口地址分别为3F0H，3F2H，3F4H，3F6H。要求通道0工作与方式3，计数初值n=1234H(BCD)。试编写初始化程序。

根据题目得知控制字为37H
0 0 1 1 0 1 1 1
通道0工作第1至2位取0 0，因为是方式3所以第5-7位取0 1 1，使用了BCD码让第8位取1，第3-4位因为n为1234则取1 1

MOV AL, 37H		;00110111，通道0,方式3,BCD,先低后高
MOV DX, 3F6H	;控制口
OUT DX, AL		;送控制字（不管通道几，控制字只能送到控制口）
MOV AL, 34H
MOV DX, 3F0		;通道0地址
OUT DX, AL		;先送n值低8位
MOV AL, 12H
OUT DX, AL		;再送n值高8位
```

#### 8253工作方式

- 方式0-计数结束中断
  - ![image-20220811163241567](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111636008.png)
  - 设定方式0，写入控制字，OUT立即变低
  - 设GATE=1，写入计数初值n后，再来一个CLK脉冲，n才真正装入计数器。之后，每来一个CLK(下降沿)，计数器减1，减至0后，OUT由低变高，可请求中断
  - 若GATE=0，暂停计数；GATE=1，继续进行
  - 若GATE=0，暂停计数，GATE=1，继续进行
  - 应用：定时/计数。定时/计数结束后，可请求中断

- 方式1-可编程单稳脉冲
  - ![image-20220811163758748](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111638577.png)
  - 设定方式2，写入控制字，OUT立即变高
  - 写入n后，并不开始计数，直至GATE出现上升沿，则在下一个CLK到来时，OUT变低并开始计数
  - 计数结束，OUT变高
  - 负脉冲宽度=T<sub>CLK</sub>*n
  - 可重复触发：计数未计数，GATE又来上升沿，则n重新装入并计数
  - 应用：作单稳态触发器，暂态宽度可调节

- 方式2-负脉冲发生器/分频器
  - ![image-20220811164157546](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111642591.png)
  - 设定方式2,写入控制字后,0UT立即变高
  - 设GATE=1,则写入初值后的下一个CLK开始计数
  - 当计数值减至1时,OUT变低,减至0时,OUT又变高,同时将n的初值自动重新装入并重复上述过程
  - OUT端输出一系列连续的负脉冲,频率= fcx/n
  - 若计数过程中写入新的n值,则本次计数结束后按新的n值进行
  - GATE=0,禁止计数,OUT变高;GATE变高, n自动装入并工作
  - 应用:作分频器/负脉冲序列发生器

- 方式3-方波发生器
  - ![image-20220811164407235](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208111644262.png)
  - 设定方式3，写入控制字后，OUT立即变高
  - 与方式2相同之处：产生连续脉冲，频率=f<sub>CLK</sub>/n
  - 与方式2不同之处：输出脉冲为正负对称的方波（n为偶数）
  - 若n为奇数，输出脉冲的负脉冲宽比正脉宽少了一个CLK周期
  - 应用：作方波发生器/分频器

- 方式4-软件触发选通
  - ![image-20220812091029028](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120910542.png)
  - 设定方式4,写入控制字后, OUT立即变高
  - 设GATE=1,写入n后的下一个CLK开始计数,当计数值减为0时,OUT变低,一个TCLK后,又变高,形成一个负脉冲
  - 软件触发(即:装入n值)一次,仅输出一个负脉冲
  - GATE=0,停止计数,GATE变高后,重新装入n,开始计数
  - 应用:(定时)产生选通脉冲(软件触发)

- 方式5-硬件触发选通
  - ![image-20220812091350190](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120915107.png)
  - 设定方式5，写入控制字，OUT立即变高
  - 写入n后，并不开始计数，直至GATE出线上升沿，则在下一个CLK到来时开始计数，计数值减为0后，OUT输出一个TCLK的负脉冲，并自动再装入n，等待GATE再来上升沿触发
  - 硬件(GATE)触发一次，仅输出一个负脉冲
  - 若计数过程种GATE又来上升沿，则重新装入n，开始计数
  - 若计数过程中写入新的n值，则再下次GATE上升沿装入新n值并计数
  - 应用：(定时)产生选通脉冲(硬件触发)

- 小结

| 方式 | 输出特点                                         | 典型应用           | OUT波形                                                      |
| ---- | ------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| 0    | OUT初值=0，计数结束变高，其他方式OUT初值均为1    | 计数结束，中断请求 | ![image-20220812092534494](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120931382.png) |
| 1    | 单稳脉冲；GATE启动麦宽=T<sub>CLK*n</sub>         | 程控脉宽，定时延时 | ![image-20220812092901882](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120932024.png) |
| 2    | 连续负脉冲；频率=f<sub>CLK*n</sub>，自动再装初值 | 脉冲发生器，分频器 | ![image-20220812092951269](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120932818.png) |
| 3    | 连续方波；频率=f<sub>CLK*n</sub>，自动再装初值   | 方波发生器，分频器 | ![image-20220812093031029](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120932337.png) |
| 4    | 单个负脉冲；软件触发                             | 选通脉冲，软件触发 | ![image-20220812093119854](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120932938.png) |
| 5    | 单个负脉冲；GATE启动自动再装初值                 | 选通脉冲，硬件触发 | ![image-20220812093152093](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208120932941.png) |

### 应用举例

#### 定时功能之一：产生各种定时波形

![image-20220812103348145](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121128606.png)

```assembly
四个端口地址：
首先片选要有效，CS连接Y4，如果使Y4为0，则A4，A3，A0为100，G1又必须为高电平为1，与门，则A9，A8为11，G2A必须为0，因为是与门，则A7，A6为00，G2B必须为0，则A5为0，M/IO自动分配0，A2和A1连接8253内部的A1，A0，所以A2和A1是区分8253内部端口的两根线，是变动的，最终的端口地址
A9~A0：
1100010000 (通道0)：310H
	   01  (通道1)：312H
	   10  (通道2)：314H
	   11  (控制口)：316H
```

```assembly
;通道0：方波，方式3
;方波周期T=n*TCLK
;n0=T/TCLK
   =fCLK/f
   =1MHz/2kHz
   =500

MOV DX, 316H ;控制口
MOV AL, 37H	 ;通道0，方式3，BCD
OUT DX, AL	 ;写控制字（参考8253控制字）00110111
MOV DX, 310H ;通道0
MOV AL, 00H
OUT DX, AL	 ;写入n低位
MOV AL, 05H
OUT DX, AL	 ;写入n高位
......		 ;2kHz方波随即产生
```

```assembly
;通道1：单稳，方式1
;脉宽T=n*TCLK
;n1=T/TCLK
   =480μs/1μs
   =480

MOV DX, 316H
MOV AL, 73H ;通道1，方式1，BCD
OUT DX, AL	;写控制字(01110011)
MOV DX, 312H;通道1
MOV AL, 80H
OUT DX, AL
MOV AL, 04H
OUT DX, AL
```

```assembly
;通道2：硬件触发单脉冲，方式5
;n2=26

MOV DX, 316H
MOV AL, 9BH	;通道2，方式5，BCD
OUT DX, AL	;写控制字(10011011)
MOV DX 314H	;通道2
MOV AL, 26H ;只写低位
OUT DX, AL	
......		;等GATE触发
```

#### 定时功能之二：长延时

![image-20220812112839589](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121128368.png)

```assembly
设8253口地址为：81H，83H，85H，87H
欲输出方波：T=20s，f=0.05Hz
分频系数
	n=2M/0.05=40000000
通道0、1串联：
	n0=5000，n1=8000
```

```assembly
;通道0
MOV AL, 35H; 方式2
OUT 87H, AL
MOV AL, 00H
OUT 81H, AL
MOV AL 50H
OUT 81H AL
```

```assembly
;通道1
MOV AL, 77H; 方式3
OUT 87H, AL
MOV AL, 00H
OUT 83H, AL
MOV AL 80H
OUT 83H AL
```

- 计数功能

![image-20220812144049207](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202209241534782.png)

```assembly
设8253口地址:FOH,F2H, F4H,F6H
对工件计数，每500个中断一次

;通道1，方式0，n=499
MOV AL, 71H
OUT 0F6H, AL
MOV AL, 99H
OUT 0F2H, AL
MOV AL, 04H
OUT 0F2H, AL

;读计数器现行值
MOV AL, 01000000B
MOV 0F6H, AL	;锁存计数器
IN AL, 0F2H		;读低8位
MOV AH, AL
IN AL, 0F2H		;读高8位
XCHG AH, AL		;AX<-计数值
```

- 8253再PC/XT中的应用

![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121503285.png)

## 串行通信

- 并行通信
  - 并行通信是把一个字符的各位数用几条线同时进行传输
  - 优点：传输速度快，信息率高
  - 缺点：比串行通信所用的电缆多
  - 应用场景：传输距离较短和数据传输率较高的场合
- 串行通信
  - 串行通信是指的是数据一位一位地传输，每一位数据占据一个固定的时间
  - 优点：比并行通信所用电缆少
  - 缺点：传输速度慢
  - 应用场景：计算机与计算机、计算机与外部设备之间的远距离通信

### 串行传送的工作方式

- 异步方式(Asynchronous)
  - ![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121503681.png)

- 同步方式(Synchronous)
  - 起始：发送一个或两个特殊字符(同步字符)，同步收发双方
  - 传输：一个接一个字符发送大量数据，不用其实与停止位
  - 特点：速度快，但需同一时钟协调、同步，硬件复杂

### 串行传输速率

> 波特率(Baud Rate)：传送数据的位数/秒(Bd)

- 异步串行通信常用的波特率：
  - 110，300，600，1200，2400，4800,9600，19.2k，28.8k，36.4k，57.6k
- 同步：>64k

### 可编程串行接口芯片

- UART：通用异步收发器（Ins 8250）
- USART：通用同步异步收发器（Intel 8251A）
- ![image-20220812160453545](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121633105.png)

### RS-232C串行口简介

- EIA(美国电子工业协会)标准，定义了数据终端设备(DTE)与数据通信设备(DCE)之前的物理接口标准
  - 传输距离：20米
    - 欲提高传输距离、传输速度和抗干扰能力，可选用RS-485接口
  - 传送速率：20kbps
  - 单端输入输出方式
  - 收发双方需共地

![image-20220812160943075](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121633359.png)

- 信号定义
	- | 插针序号 | 信号名称 | 引脚功能                  | 信号方向 |
  | -------- | -------- | ------------------------- | -------- |
  | 1        | PGND     | 保护地                    |          |
  | 2(3)     | TXD      | 发送数据(串行输出)        | DTE<-DCE |
  | 3(2)     | RXD      | 接收数据(串行输入)        | DTE->DCE |
  | 4(7)     | RTS      | 请求发送                  | DTE<-DCE |
  | 5(8)     | CTS      | 允许发送                  | DTE<-DCE |
  | 6(6)     | DSR      | DCE就绪(数据建立就绪)     | DTE<-DCE |
  | 7(5)     | SGND     | 信号地                    |          |
  | 8(1)     | DCD      | 载波检测                  | DTE<-DCE |
  | 20(4)    | DTR      | DTE就绪(数据终端准备就绪) | DTE->DCE |
  | 22(9)    | RI       | 振铃指示                  | DTE<-DCE |

- 信号电平

  - RS-232C采用<span style='color:red'>负逻辑电平</span>
    - DC(-12V或-15V)：逻辑1
    - DC(+12V或+15V)：逻辑0

  - RS232C与MOS、TTL电平不兼容，连接时需外加电平转换电路
    - ![image-20220812162006562](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121633484.png)


  - MAX220~MAX249系列芯片
    - <span style='color:red'>两路双向</span>电平转换电路：<span style='color:red'>TTL/CMOS<- ->RS-232C</span>
    - <span style='color:red'>只需+5V电源供电</span>(内含电压倍增电路)
    - MAX232典型接法和具体应用可参见MAXIM数据手册


## A/D与D/A转换

### 概述

- 微机控制系统的组成
  - ![image-20220812163319083](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121633633.png)

- 采用、量化和编码

  - 采样
  - ![image-20220812164223015](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121642210.png)

  - 编码
  - ![image-20220812164334385](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121713902.png)

### D/A转换器

#### 基本概念

> 转换原理：权电阻网络

![image-20220812171239340](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121713263.png)

![image-20220812171258629](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121713755.png)

#### DAC主要计数指标

- 分辨率
  - 输入数据发生1LSB变化时对应的输出模拟量的变化
    - <span style='color:red'>分辨率△=FSR/2<sup>n</sup></span>
  - 如：8位DAC：△=FSR/256=0/39%*FSR
  - 12位DAC：△=FSR/4096=0.0244%*FSR
- 建立时间t<sub>s</sub>：100ns，1μs，10μs，100μs
- 精度：一般小于1/2LSB
- 线性误差

#### DAC0832

- 内部R-2R网络，NSC产品
- 主要性能指标
  - 分辨率：<span style="color:red">8位</span>
  - 转换时间：<span style="color:red">1μs</span>
  - 满意误差：±1LSB
  - 参考电压：±10V
  - 单电源：<span style="color:red">＋5</span>~＋15V
- 可直接与8086/8088、MCS-51等连用

- 内部结构与引脚功能
  - ![image-20220812175504854](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208121755156.png)

- **三种工作方式**

- 直通方式

  - ![image-20220815094714901](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151002119.png)

  - 输入数字量即可直接进行D/A转换
  - 无需控制
  - 如：波形发生器等

- 单缓冲模式

  - ![image-20220815100230683](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151002357.png)
  - ![image-20220815103227087](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151032096.png)

```assembly
	MOV DX, 320H
	MOV AL, 0FFH
LP: INC AL
	OUT DX, AL	;启动转换
	CALL DLY
	JMP LP
```

- 双缓冲模式
  - ![image-20220815103803415](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151038105.png)
  - ![image-20220815103402311](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151034887.png)
  - 

```assembly
MOV DX, 320H ;指向输入寄存器
MOV AL, DATA ;AL<-待转换数字量
OUT DX, AL	 ;打入输入寄存器
INC DX		 ;指向DAC寄存器
OUT DX, AL	 ;选通DAC寄存器，启动D/A
```

### A/D转换

#### 基本概念

- ADC类型：双积分型、逐次逼近型、并行、![image-20220815104626769](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151046380.png)
  - 逐次逼近型ADC
    - 较高的转换速度、转换精度和适中的价格,应用最为广泛。

  - 双积分型ADC
    - 转换速度慢,但转换精度高、抗干扰能力强、性价比高,特别适合于缓变信号的采集。

  - ![image-20220815104626769](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151046380.png)
    - 分辨率高、线性度好和抑制噪声的能力强,近年来逐渐得到重视并获得了较广泛的应用。

  - V-F型变换器
    - 将模拟电压信号转换成脉冲频率信号,特点是连线简单、抗电磁干扰能力强,适用于远距离传输。

- 性能指标
  - 分辨率，精度，转换数据，输入范围，输出数据格式
- 逐次逼近型ADC抓换原理
  - ![image-20220815110221229](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151437798.png)

#### ADC0809

- 主要性能指标
  - <span style="color:red">8位、8通道逐次逼近型A/D转换器</span>
  - <span style="color:red">分辨率：8位</span>
  - 最大不可调误差：小于±1LSB
  - <span style="color:red">转换速度：f<sub>CLK</sub>=640KHz(典型值)，转换时间100μs</span>
  - 单+5V，模拟输入范围0~+5V，无需零点和满度调整
  - 内置8通道模拟量选通开关控制
  - 数字量锁存三态输出，输出与TTL电平兼容
  - 功耗15mW
- 功能与引脚
  
- ![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208171442384.png)
  - ![image-20220815144538895](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151503502.png)

- 硬件连接
  - ![image-20220815150322180](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202208151503233.png)

```assembly
多路数据采集系统

     MOV CX, 0008H ;通道数
     NIV CX, 300H  ;0通道
NEXT:OUT DX, AL    ;启动AD
	 PUSH DX	   ;保存通道号
	 MOV DX, 308H  ;状态口
POLL:IN AL, DX	   ;读EOC状态
	 TEST AL, 80H	
	 JNZ POLL	   ;EOC≠0，等待
N_END:IN AL,DX
	 TEST AL, 80H
	 JZN_END	   ;EOC=0，等待
	 POP DX		   ;恢复通道号
	 IN AL, DX	   ;读转换信号
	 MOV [SI], AL  ;存结果
	 INC DX		   ;指向下一通道
	 INC SI	
	 LOOP NEXT
```
