# 数据结构与算法

## 数据结构与算法概述

- 数据结构与算法的关系

  - 数据结构（data structure）是一门研究 组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮，更加有效率的代码

  - 程序 = 数据结构 + 算法

  - 数据结构是算法的基础

- 数据结构包括：线性结构和非线性结构
  - **线性结构：**
    - 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
    - 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表成为顺序表，顺序表中的存储元素是连续的
    - 链式存储的线性结构称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
    - 线性结构常见的有：数组、队列、链表和栈。
  - **非线性结构**：
    - 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

## 稀疏数组和队列

### 稀疏数组(sparspearray)

- **实际问题**

  - 编写五子棋程序中，有存盘和续上盘功能

  - ![image-20240305170046055](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403070914473.png)

  - 分析问题：

    因为该二维数组有很多值是默认值0，因此记录了很多没有意义的数据 => 稀疏数组

#### 基本介绍

> 当一个数组大部分元素为 0,或者为同一个值的数组时，可以使用稀疏数组来保存该数组

- 稀疏数组的处理方法

  记录数组一共有几行几列，有多少不同的值

  把具有不同值的元素的行列及值记 录在一个小规模的数组中，从而缩小程序的规模

  ![image-20240305173610434](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403070914484.png)

#### 应用实例

- ​	使用稀疏数组，来保存类似前面的二维数组（棋盘、地图等等）
- 把稀疏数组存盘，并且可以从新恢复原来的二维数组数据

![image-20240307091357828](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403070914559.png)

- 二维数组转稀疏数组思路:
  1) 遍历原始的二维数组,得到有效数据的个数sum
  2) 根据sum可以创建稀疏数组`sparseArr[sum+1][3]`
  3) 将二维数组的有效数据存入稀疏数组
- 稀疏数组转换原始二维数组的思路
  1) 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的`chessArr = int[11][11]`
  2) 在读取稀疏数组后几行的数据，并赋值给原始数组

实例代码：

```java
public class SparseArr {
    public static void main(String[] args) {
        // 创建一个二维数组 11*11
        // 0: 表示没有棋子，1表示黑子，2表示蓝子
        // 给二维数组进行赋值
        int[][] chessArr = new int[11][11];
        chessArr[1][2] = 1;
        chessArr[3][3] = 2;

        // 输入原始二位数组
        System.out.println("原始的二维数组：");
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[0].length; j++) {
                System.out.print(chessArr[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();

        // 将二维数组转换为稀疏数组
        // 1. 先遍历二维数组得到非0数据的个数
        int sum = 0;
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[0].length; j++) {
                if (chessArr[i][j] != 0) {
                    sum++;
                }
            }
        }

        // 创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        // 给稀疏数组第一行进行赋值对应的行，列，总数值
        sparseArr[0][0] = chessArr.length;
        sparseArr[0][1] = chessArr[0].length;
        sparseArr[0][2] = sum;

        // 遍历二维数组，将非0的值存放到sparseArr中
        int count = 0; // count用于记录是第几个非0数据
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[0].length; j++) {
                if (chessArr[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr[i][j];
                }
            }
        }

        // 输出稀疏数组
        System.out.println("得到的稀疏数组为：");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }
        System.out.println();

        // 将稀疏数组保存到本地文件
        // 1. 创建一个文件
        // 2. 将稀疏数组的数据写入到文件中

        // 创建FileWriter对象
        /**
         * 创建一个FileWriter对象，传入你想要写入的文件名。
         * 创建一个BufferedWriter对象，传入FileWriter对象。
         * 遍历稀疏数组，将每个元素转换为字符串，并添加适当的分隔符（例如，逗号或空格）。
         * 使用BufferedWriter的write方法将字符串写入文件。
         * 在写入所有数据后，关闭BufferedWriter。
         */
        try {
            FileWriter writer = new FileWriter("map.data");
            BufferedWriter bufferedWriter = new BufferedWriter(writer);
            // 对稀疏数组进行遍历读取
            // 创建BufferedWriter对象
            for (int i = 0; i < sparseArr.length; i++) {
                for (int j = 0; j < sparseArr[0].length; j++) {
                    bufferedWriter.write(sparseArr[i][j] + " ");
                }
                // 读取完一行,进行换行
                bufferedWriter.newLine();
            }
            bufferedWriter.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // 读取文件中的稀疏数组
        /**
         创建一个FileReader对象，传入你想要读取的文件名。
         创建一个BufferedReader对象，传入FileReader对象。
         读取文件的第一行，获取原始二维数组的大小。
         根据第一行的数据创建原始的二维数组。
         继续读取文件，将数据填充到原始的二维数组中。
         在读取所有数据后，关闭BufferedReader
         */
        int[][] sparseArrRecover;
        try {
            // 创建FileReader对象
            FileReader reader = new FileReader("map.data");
            // 创建BufferedReader对象
            BufferedReader bufferedReader = new BufferedReader(reader);

            // 读取第一行数据，获取原始二维数组的大小
            String line = bufferedReader.readLine();
            String[] readArr = line.split(" ");
            sparseArrRecover = new int[Integer.parseInt(readArr[0])][Integer.parseInt(readArr[1])];

            // 继续读取文件,将数据填充到原始的二维数组中
            while ((line = bufferedReader.readLine()) != null) {
                readArr = line.split(" ");
                sparseArrRecover[Integer.parseInt(readArr[0])][Integer.parseInt(readArr[1])] = Integer.parseInt(readArr[2]);
            }

            // 关闭Bufferedreader
            bufferedReader.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }


        // 将稀疏数组恢复成 ==> 原始的二维数组
        // 1. 先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组
        // 2. 在读取稀疏数组后几行的数据,并赋值给原始的二维数组即可
        // for (int i = 1; i < sparseArr.length; i++) {
        //     sparseArrRecover[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        // }

        // 输入恢复的稀疏数组
        for (int[] row : sparseArrRecover) {
            for (int data : row) {
                System.out.printf("%d ", data);
            }
            System.out.println();
        }
    }
}
```

### 队列

#### 队列介绍

- 队列是一个有序列表，可以用数组或是链表来实现
- 遵循先入先出原则。即：现存如队列的数据，要先取出。后存入的要后取出
- 示意图

![image-20240312154721751](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261436975.png)

#### 数组模拟队列

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列的声明如下图，其中`maxSize`是该队列的最大容量
- 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 `front` 及 `rear` 分别记录队列前后端的下标，`front`会随着数据输出而改变，而rear则是随着数据输入而改变（如上图）

- 当我们将数据存入队列时称为 “addQueue”，addQueue的处理需要有两个步骤，思路分析：
  - 将尾指针往后移：rear+1，当 `front == rear`【空】
  - 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的 数组元素中，否则无法存入数据。`rear == maxSize - 1` 【队列满】
- 代码实现

```java
class ArrayQueue {
    private int maxSize; // 队列的最大容量
    private int front; // 队列头
    private int rear; // 队列尾
    private int[] arr; // 该数组用于存放数据，模拟队列

    // 创建队列构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; // 指向队列头部,分析出front是指向队列头的前一个位置.
        rear = -1; // 指向队列尾, 指向队列尾的数据(即就是队列最后一个数据)
    }

    // 判断队列是否满
    public boolean isFull() {
        return rear == maxSize - 1;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加队列
    public void addQueue(int n) {
        // 判断队列是否满
        if (isFull()) {
            System.out.println("队列满,不能加入数据");
            return;
        }
        rear++; // 让rear后移
        arr[rear] = n;
    }

    // 获取队列的数据,出队列
    public int getQueue() {
        // 判断队列是否满
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空,不能取数据");
        }
        front++; // 后移一下
        return arr[front];
    }

    // 显示队列所有数据
    public void showQueue() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的");
            return;
        }

        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    // 显示队列的头数据,不是取数据
    public int headQueue() {
        if (isEmpty()) {
            throw new RuntimeException("队列空,没有数据~");
        }
        return arr[front + 1];
    }
}
```

问题分析:

目前数组使用一次就不能使用了，没有达到复用的效果

将这个数组使用算法，该进成环形的数组，取模：%

#### 数组模拟环形队列

- 对前面的数组模拟队列的优化，充分利用数组。因此将数组看作是一个环形的。（通过取模的方式来实现）

![image-20240312154721751](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261436032.png)

- 分析说明：
  - front 变量的含义做一个调整，front就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，front的初始值 = 0
  - rear 变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值 = 0
  - 尾索引的下一个为头索引时表示队列已满，即将队列容量空出一个作为约定，这个再做判断队列满的时候需要注意 `(rear + 1) % maxSize == front` 【满】
  - 对队列为空的条件，`rear == front` 【空】 
  - 当我们这样分析，队列中有效的数据的个数 `(rear + maxSize + front) % maxSize`

```java
class CircleArrayQueue {
    // 表示队列最大容量
    private int maxSize;
    // 队列头：front就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，front的初始值 = 0
    private int front;
    // 队列尾：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值 = 0
    private int rear;
    // 用于存放数据，模拟队列
    private int[] arr;

    public CircleArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        front = 0;
        rear = 0;
        arr = new int[maxSize];
    }

    // 判断队列是否满
    public boolean isFull() {
        return (rear + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("队列已满，无法添加~");
            return;
        }
        // 直接将数据加入
        arr[rear] = n;
        // 将rear后移，需要考虑取模
        rear = (rear + 1) % maxSize;
    }

    // 获取队列数据，出队列
    public int getQueue() {
        // 判断队列是否为空
        if (isEmpty()) {
            // 抛出异常
            throw new RuntimeException("队列已空，无法取出~");
        }
        // front是指向队列第一个元素
        // 1. 先将 front 对应的值保存到一个临时变量
        // 2. 将 front 后移
        // 3. 将临时保存的变量返回
        int temp = arr[front];
        front = (front + 1) % maxSize;
        return temp;
    }

    // 求出当前队列有效数据的个数
    public int size() {
        return (rear + maxSize - front) % maxSize;
    }

    // 显示队列数据
    public void showQueue() {
        if (isEmpty()) {
            // 抛出异常
            System.out.println("队列空的");
            return;
        }
		// 因为 front 指向队列头,有效元素从front开始,一直延伸到rear指向的位置, 而 front + size() 则是表示队列技术的位置
        // i % maxSize 是为了确保索引在队列的有效数据范围内容, 考虑到环形队列 i 超超过队列大小时候, 需要将其循环到队列起始位置
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 显示头元素
    public int headQueue() {
        if (isEmpty()) {
            // 抛出异常
            throw new RuntimeException("队列已空，无法取出~");
        }
        return arr[front];
    }
}
```

## 链表

### 链表介绍

> 链表是有序的列表

- 链表内存结构

  - 链表是以节点的方式来存储的，是链式存储
  - 每个节点包含
    - data域：存储的数据
    - next域：指向下一个节点

  - 链表的各个节点不一定是连续存放

  - 链表分带头节点的链表和没有头节点的链表

![image-20240314093444963](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261436493.png)

### 单向链表

- 链表（带头节点）逻辑结构示意图

![image-20240314094831418](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261437257.png)

#### 单链表的实现

- 添加(创建)
  - 第一种方法：直接添加到尾部
    - 先创建一个head头节点，作用就是表示单链表的头
    - 后面每添加一个节点，就直接加入到链表的最后变量
    - 通过一个辅助变量，帮助遍历整个单链表
  - ![image-20240318151246268](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261436498.png)
  - 第二种方法：根据编号顺序插入到指定位置（如果有这个排名则添加失败，并给出提示）
    - 首先找到新添加的节点位置，是通过辅助变量（指针），通过遍历搞定
    - `新的节点.next = temp.next`
    - `将temp.next = 新的节点`
    - ![image-20240318172305099](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261437355.png)

- 修改:
  - 先找到该节点，通过遍历
  - `temp.name = newListNode.name;` 
  - `temp.nickName = newListNode.nickName;`
- 删除
  - 先找到需要删除的这个节点的前一个节点
  - `temp.next = temp.next.next`
  - 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收

![image-20240319150251819](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261437872.png)

```java
// 定义SingleLinkedList 单链表,管理英雄
class SingleLinkedList {
    // 先初始化头节点, 头节点不要动, 不存放具体的数据
    private ListNode head = new ListNode(0, "", "");

    // 第一种方式: 直接插入到尾部
    // 添加节点到单向链表
    // 思路: 当不考虑编号的顺序时
    // 1. 找到当前链表的最后节点
    // 2. 将最后这个节点的next 指向新的节点
    public void add(ListNode listNode) {
        // 因为head节点不能动, 因此我们需要一个辅助变量temp
        ListNode temp = head;

        // 遍历链表,找到最后
        while (true) {
            // 找到链表的最后
            if (temp.next == null) {
                break;
            }
            // 如果没有找到最后, 将temp后移
            temp = temp.next;
        }

        // 当推出while循环时,temp就指向了链表的最后
        // 将最后的节点指向新的节点
        temp.next = listNode;
    }

    // 第二种方式在添加英雄时,根据排名将英雄插入到指定位置
    // (如果有这个排名则,则添加失败,并给出提示)
    public void addByOrder(ListNode listNode) {
        // 因为头节点不能动, 通过辅助指针来帮助找到添加的位置
        // 因为单链表,因此找的temp位于添加位置的前一个节点,否则无法加入
        ListNode temp = head;
        // 标识添加的编号是否存在, 默认为false
        boolean flag = false;
        while (true) {
            // 说明temp已经在链表的最后
            if (temp.next == null) {
                break;
            }
            // 位置找到,就在temp后面插入
            if (temp.next.no > listNode.no) {
                break;
                // 说明添加的ListNode的编号已然存在
            } else if (temp.next.no == listNode.no) {
                flag = true;
                break;
            }
            // 后移,遍历当前链表
            temp = temp.next;
        }
        // 判断flag, 编号已经存在,不能添加
        if (flag) {
            System.out.printf("准备插入的英雄的编号 %d 已经存在了! 不能加入! \n", listNode.no);
        } else {
            // 插入到链表中, temp的后面
            listNode.next = temp.next;
            temp.next = listNode;
        }
    }

    // 修改节点信息,根据no编号来修改,即no编号不能改
    // 说明
    // 1. 根据 newListNode 的 no 来修改即可
    public void update(ListNode newListNode) {
        // 判断是否为空
        if (head.next == null) {
            System.out.println("链表为空!");
            return;
        }
        // 找到需要修改的节点, 根据no编写
        // 定义一个辅助变量
        ListNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true) {
            // 到链表的最后,已经遍历完链表了
            if (temp == null) {
                break;
            }
            if (temp.no == newListNode.no) {
                // 找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag判断是否找到该节点
        if (flag) {
            temp.name = newListNode.name;
            temp.nickname = newListNode.nickname;
        } else {
            // 没有找到
            System.out.printf("没有找到编号为 %d 的节点,不能修改!\n", newListNode.no);
        }
    }

    // 删除节点信息
    // head节点不能动,因此需要temp辅助节点找到待删除节点的前一个节点
    // 说明我们在比较时,是temp.next.no 和 需要删除的节点的no比较
    public void del(int no) {
        ListNode temp = head;
        // 是否找到待删除节点的前一个节点
        boolean flag = false;
        while (true) {
            // 当已经到链表的最后
            if (temp.next == null) {
                break;
            }
            // 找到待删除结点的前一个节点
            if (temp.next.no == no) {
                flag = true;
                break;
            }
            // temp后移
            temp = temp.next;
        }

        // 找到
        if (flag) {
            temp.next = temp.next.next;
        } else {
            System.out.println("没有找到需要删除的节点, 无法删除");
        }
    }

    // 显示链表[遍历]
    public void list() {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        // 因为头节点不能动,因此需要一个辅助变量进行遍历
        ListNode temp = head.next;

        while (true) {
            // 判断是否到链表最后
            if (temp == null) {
                break;
            }
            // 输出节点信息
            System.out.println(temp);
            // 将next后移
            temp = temp.next;
        }
    }
}

// 定义一个ListNode, 每个ListNode对象, 就是一个节点
class ListNode {
    public int no;
    public String name;
    public String nickname;
    public ListNode next; // 指向下一个节点

    // 构造器
    public ListNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "ListNode[" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                ']';
    }
}
```

#### 获取单链表节点的个数

（如果带头节点的链表，不统计头节点）

```java
// 方法: 获取到单链表的节点的个数
public static int getLength(ListNode head) {
    if (head.next == null) {
        return 0;
    }
    int length = 0;
    // 定义一个辅助遍历
    ListNode cur = head.next;
    while (cur != null) {
        length++;
        cur = cur.next;
    }
    return length;
}
```

#### 查找单链表中的倒数第k个节点

```java
// 查找单链表中的倒数第k个节点
// 1. 编写一个方法, 接收head节点, 同时接收一个index
// 2. index表示倒数第index个节点
// 3. 先把链表从头到尾遍历,得到链表的总的长度, getLength
// 4. 得到size后,从链表第一个开始遍历,遍历(size-index)个节点,就可以得到了
// 5. 如果找到了返回该节点,否则返回空
public static ListNode findLastIndexNode(ListNode head, int index) {
    // 如果链表为空,返回null
    if (head.next == null) {
        return null;
    }
    // 第一次遍历得到链表的长度
    int size = getLength(head);
    // 第二次遍历 size-index 位置,就是倒数第k个节点
    // 先做一个index的校验
    if (index <= 0 || index > size) {
        return null;
    }
    // 定义一个辅助变量
    ListNode temp = head.next;
    for (int i = 0; i < size - index; i++) {
        temp = temp.next;
    }
    return temp;
}
```

#### 单链表反转

![image-20240326143614911](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261437157.png)

- 先定义一个节点 `reverseHead = new ListNode();`
- 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表的最前端
- 原来的链表的 `head.next = reverseHead.next`


```java
// 单链表的反转
public static void reverseList(ListNode head) {
    // 如果当前链表为空, 或者只有一个节点, 无需反转,直接返回
    if (head.next == null || head.next.next == null) {
        return;
    }

    // 定义一个辅助指针, 遍历原来的链表
    ListNode cur = head.next;
    // 指向当前节点 [cur] 的下一个节点
    ListNode next = null;
    ListNode reverseHead = new ListNode(0, "", "");

    // 遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端
    while (cur != null) {
        // 先暂时保存当前节点的下一个节点
        next = cur.next;
        // 将cur的下一个节点指向新的链表的最前端
        cur.next = reverseHead.next;
        // 将cur连接到新的链表上
        reverseHead.next = cur;
        // 使当前节点后移
        cur = next;
    }
    // 将head.next指向reverseHead.next, 实现了单链表的反转
    head.next = reverseHead.next;
}
```

#### 逆序打印单链表

- 逆序打印单链表
- 方式一：先将单链表进行反转操作，然后在遍历即可，会破坏原来单链表的结构
- 方式二：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，实现逆序打印的效果

```java
// 单链表逆序打印
// 利用栈先进后出,实现逆序打印
public static void reversePrint(ListNode head) {
    if (head.next == null) {
        System.out.println("空链表,无法打印!");
        return;
    }
    // 创建一个栈, 将各个节点压入栈
    Stack<ListNode> stack = new Stack<>();
    ListNode cur = head.next;
    // 将链表所有节点压入栈中
    while (cur != null) {
        stack.push(cur);
        // cur后移, 这样就可以压入下一个节点
        cur = cur.next;
    }
    // 将栈中的节点进行打印,pop出栈
    while (stack.size() > 0) {
        System.out.println(stack.pop());
    }
}
```

#### 合并两个有序的链表

> 合并两个有序的链表，合并完后仍然有序

1. 创建一个虚拟节点 `dummy` 作为合并后的链表的头部，以便于返回结果。
2. 使用两个指针 `cur1` 和 `cur2` 分别指向两个链表的头节点的next。
3. 遍历两个链表，比较当前节点的值，将较小的节点连接到合并后的链表中，并更新指针。
4. 继续比较直到其中一个链表遍历完毕。
5. 将剩余未遍历完的链表直接连接到合并链表的末尾。
6. 返回虚拟节点 `dummy` 的下一个节点，即为合并后的有序链表。

```java
// 合并两个有序链表，合并后仍然有序
// 优化后的合并两个有序链表的方法
public static ListNode mergeLinkedList(ListNode l1, ListNode l2) {
    // 判断两个链表是否为空
    if (l1 == null && l2 == null) {
        System.out.println("两个链表为空，无法进行合并");
        return null;
    }

    // 创建一个头节点作为合并后的链表的头部
    ListNode dummy = new ListNode(0, "", "");
    ListNode current = dummy;
    ListNode cur1 = l1.next;
    ListNode cur2 = l2.next;

    // 遍历两个链表，比较节点值并合并
    while (cur1 != null && cur2 != null) {
        if (cur1.no < cur2.no) {
            current.next = cur1;
            cur1 = cur1.next;
        } else {
            current.next = cur2;
            cur2 = cur2.next;
        }
        current = current.next;
    }

    // 将剩余未遍历完的链表直接连接到合并链表的末尾
    current.next = (cur1 != null) ? cur1 : cur2;

    // 返回合并后的有序链表的头节点
    return dummy;
}
```

### 双向链表

- 单向链表缺点分析：
  1. 单向链表，查找的方向只能是一个方向，而双向链表可以向前后向后查找
  2. 单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除

- 双向链表逻辑结构图

![在这里插入图片描述](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403261654111.png)

![image-20240326165430322](D:\Downloads\Video\img\image-20240326165430322.png)

- 遍历方法和单链表一样，只是可以向前也可以向后，
- 添加
  - 添加到双向链表的最后
    - 先找到双向链表的最后节点
    - `temp.next  = newListNode`
    - `newListNode.pre = temp`
  - 添加到双向链表的中间
    - 找到需要添加节点的前一个节点
    - `newListNode.next = temp.next`
    - `newListNode.pre = temp`
    - `temp.next.pre = newListNode`
    - `temp.next = newListNode`
- 修改
  - 先找到该节点，通过遍历
  - `temp.name = newListNode.name;` 
  - `temp.nickName = newListNode.nickName;`
- 删除
  - ![image-20240326172147657](D:\Downloads\Video\img\image-20240326172147657.png)
  - 直接找到要删除的这个节点
  - `temp.pre.next = temp.next`
  - `temp.next.pre = temp.pre`

#### 双向链表的实现

```java
class DoubleLinkedList {
    // 先初始化一个头节点,头节点不要动,不要放具体的数据
    private ListNode head = new ListNode(0, "", "");

    // 添加一个节点到双向链表的最后
    public void add(ListNode listNode) {
        // 使用辅助变量,进行添加
        ListNode temp = head;

        while (true) {
            // 如果遍历到最后一个
            if (temp.next == null) {
                break;
            }
            // 后移
            temp = temp.next;
        }
        // 当退出while循环时,链表就指向了最后
        // 形成一个双向链表
        temp.next = listNode;
        listNode.pre = temp;
    }

    // 按照节点大小进行添加
    public void addByOrder(ListNode listNode) {
        // 如果链表为空，直接插入新节点
        if (head.next == null) {
            head.next = listNode;
            listNode.pre = head;
            return;
        }

        // 定义一个辅助节点
        ListNode temp = head;
        // 表示是否找到了插入该节点的地方
        boolean flag = false;

        // 遍历链表，找到合适的插入位置
        while (temp.next != null) {
            // 如果找到相同编号的节点，设置标志并跳出循环
            if (temp.next.no == listNode.no) {
                flag = true;
                break;
            }
            // 如果找到比当前节点编号大的节点，跳出循环
            if (temp.next.no > listNode.no) {
                break;
            }
            temp = temp.next; // 更新辅助节点
        }

        // 如果找到相同编号的节点，输出提示信息
        if (flag) {
            System.out.printf("已经存在编号为 %d 的节点，无法进行添加\n", listNode.no);
        } else {
            // 如果插入位置是链表末尾
            if (temp.next == null) {
                temp.next = listNode;
                listNode.pre = temp;
            } else {
                // 在中间插入节点
                listNode.next = temp.next;
                listNode.pre = temp;
                temp.next.pre = listNode;
                temp.next = listNode;
            }
        }
    }

    // 修改节点信息,根据no编号来修改,即no编号不能改
    // 说明
    // 1. 根据 newListNode 的 no 来修改即可
    public void update(ListNode newListNode) {
        // 判断是否为空
        if (head.next == null) {
            System.out.println("链表为空!");
            return;
        }
        // 找到需要修改的节点, 根据no编写
        // 定义一个辅助变量
        ListNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true) {
            // 到链表的最后,已经遍历完链表了
            if (temp == null) {
                break;
            }
            if (temp.no == newListNode.no) {
                // 找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag判断是否找到该节点
        if (flag) {
            temp.name = newListNode.name;
            temp.nickName = newListNode.nickName;
        } else {
            // 没有找到
            System.out.printf("没有找到编号为 %d 的节点,不能修改!\n", newListNode.no);
        }
    }

    // 删除
    // 1. 对于双向链表, 我们可以直接找到要删除的本身节点
    // 2. 找到后,自我删除即可
    public void del(int no) {
        // 判断当前链表是否为空
        if (head.next == null) {
            System.out.println("链表为空~");
            return;
        }

        // 辅助变量(指针)
        ListNode temp = head.next;
        // 标志是否找到该节点
        boolean flag = false;
        while (true) {
            // 已经到达链表的最后
            if (temp == null) {
                break;
            }
            if (temp.no == no) {
                // 找到待删除节点的前一个节点temp
                flag = true;
                break;
            }
            // temp后移,进行遍历
            temp = temp.next;
        }
        if (flag) {
            temp.pre.next = temp.next;
            // 判断是否是最后一个节点, 如果是则不执行, 否则会出现空指针
            if (temp.next == null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.printf("没有找到编号为 %d 的元素", no);
        }
    }

    // 显示链表,遍历
    public void list() {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空,无法遍历!");
            return;
        }

        // 创建一个辅助节点,用来遍历
        ListNode temp = head.next;

        // 遍历链表
        while (true) {
            // 判断链表是否到达最后
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            // 后移temp
            temp = temp.next;
        }
    }

    // 返回头节点
    public ListNode getHead() {
        return head;
    }
}

// 定义ListNode,每一个ListNode都是一个节点
class ListNode {
    public int no;
    public String name;
    public String nickName;
    public ListNode next; // 指向下一个节点,默认为 null
    public ListNode pre; // 指向上一个节点,默认为 null

    public ListNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "ListNode[" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                ']';
    }
}
```

### 环形链表

单项环形链表

- 构建单项环形链表的思路
  - 先创建第一个节点，让first指向该节点， 并形成环形
  - 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中
- ![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403281140344.png)
- 遍历环形链表
  - 让一个辅助指针`temp`，指向`head`节点
  - 然后通过while循环遍历该环形链表即可
  - `temp.next=head` 结束

```java
class CircleSingleLinkedList {
    // 先创建一个head节点, 当前没有编号
    private ListNode head;

    public CircleSingleLinkedList() {
        this.head = null;
    }

    // 添加节点，构建成一个环形链表
    public void add(int num) {
        // 创建新节点
        ListNode newNode = new ListNode(num);
        // 如果链表为空，将新节点作为头节点并构成环
        if (head == null) {
            head = newNode;
            head.next = head;
        } else {
            // 遍历链表找到尾节点
            ListNode temp = head;
            while (temp.next != head) {
                temp = temp.next;
            }
            // 将新节点添加到尾节点后，构成环形
            temp.next = newNode;
            newNode.next = head;
        }
    }

    // 遍历当前环形链表
    public void list() {
        // 判断链表是否为空
        if (head == null) {
            System.out.println("链表为空!");
            return;
        }
        // 从头节点开始遍历链表
        ListNode temp = head;
        do {
            System.out.printf("编号为: %d\n", temp.no);
            temp = temp.next;
        } while (temp != head);
    }
}


class ListNode {
    // 编号
    public int no;
    // 指向下一个节点
    public ListNode next;

    public ListNode(int no) {
        this.no = no;
        this.next = null;
    }
}
```

##### 约瑟夫(`Josephu`)问题

- 有 n 个人（编号从 1 到 n）围坐在一圈，约定编号为`k (1<=k<=n)`开始报数，报到 m 的人出列，然后从出列的下一个人开始从1开始重新报数，数到m的那个人有出列，直到所有人都出列。产生一个出队的编号的序列
- 思路
  - 创建一个辅助指针(变量) helper，事先应该指向环形变量最后节点
  - 在报数之前，先使 head 和 helper 移动 `k-1` 次，移动到第k个节点，从k开始报数
  - 当报数时，让 head 和 helper 同时移动 `m-1` 次
  - 这时就将 head 指向的小孩出圈 `head = head.next` ，`helper.next = head`
- 约瑟夫问题示意图
  - n=6, 有6个人
  - k=1, 从第一个开始报数
  - m=3,数三下
  - 出队列的顺序：3 -> 6 -> 4 -> 2 -> 5 -> 1
  - ![image](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202403281412002.png)

```java
/**
     * 根据用户的输入, 计算出出圈的顺序
     *
     * @param k    表示从第几个开始数
     * @param m    表示数几下
     * @param nums 表示有多个人在圈中
     */
public void solve(int k, int m, int nums) {
    // 对数据进行校验
    if (head == null || k < 1 || k > nums) {
        System.out.println("参数输入有误,请重新输入!");
        return;
    }
    // 创建一个辅助指针, 帮助完成出圈
    ListNode helper = head;
    // 创建一个helper辅助遍历, 事先指向环形变量最后的节点
    while (true) {
        if (helper.next == head) {
            break;
        }
        helper = helper.next;
    }
    // 在报数之前，先使 head 和 helper 移动k-1次
    // 移动到第k个节点，从k开始报数
    for (int i = 0; i < k - 1; i++) {
        head = head.next;
        helper = helper.next;
    }
    // 当报数时，让 head 和 helper 同时移动m-1次
    // 然后出圈, 直到圈中只有一个节点
    while (true) {
        // 说明圈中只有一个节点
        if (helper == head) {
            break;
        }
        // 让head 和 helper同时移动m - 1次
        for (int i = 0; i < m - 1; i++) {
            head = head.next;
            helper = helper.next;
        }
        // 这时, head指向的节点,就是要出圈的人
        System.out.printf("编号为 %d 出圈\n", head.no);
        // 这是将 head 指向的人出圈
        head = head.next;
        helper.next = head;
    }
    System.out.printf("最后留在圈中得编号为 %d \n", head.no);
}
```

 ## 栈

> 栈是一个先入后出（FILO-First In Last Out）的有序列表
>
> 栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top），另一端为固定的一端，称为栈底（Bottom）
>
> 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

入栈（Push）与出栈（Pop）图示：

![](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404011533242.png)

![image-20240401154144525](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404011541562.png)

### 数组模拟栈

- 使用数组来模拟栈
- 定义一个top来表示栈顶，初始化为 -1
- 入栈：当有数据加入到栈中，`top++，stack[top]=data;`
- 出栈：`int value = stack[top]; top--; return value;`

![image-20240401155139237](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404011551317.png)

```java
// 定义一个 ArrayStack 表示栈
class ArrayStack {
    // 栈的大小
    private int maxSize;
    // 数组，模拟栈，数据就放在该数组中
    private int[] stack;
    // top表示栈底，初始化为-1
    private int top = -1;
    // 构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    // 栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }
    // 栈空
    public boolean isEmpty() {
        return top == -1;
    }
    // 入栈
    public void push(int val) {
        // 先判断栈满
        if (isFull()) {
            System.out.println("栈满，无法放入!");
            return;
        }
        top++;
        stack[top] = val;
    }

    // 出栈, 将栈底的数据返回
    public int pop() {
        // 先判断是否为空
        if (isEmpty()) {
            throw new RuntimeException("栈空，无法弹出!");
        }
        int temp = stack[top];
        top--;
        return temp;
    }

    // 显示栈的情况[遍历栈],遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据~");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
}
```

### 链表模拟栈

```java
// 定义链表节点类
class ListNode {
    public int no; // 节点数据
    public ListNode next; // 指向下一个节点的引用
    // 节点构造方法
    public ListNode(int no) {
        this.no = no;
        this.next = null;
    }
    @Override
    public String toString() {
        return "ListNode{" + "no=" + no;
    }
}

// 定义基于链表的栈类
class LinkListStack {
    private ListNode top; // 栈顶节点
    // 栈的构造方法
    public LinkListStack() {
        this.top = null;
    }
    // 入栈操作
    public void push(int data) {
        ListNode listNode = new ListNode(data);
        if (top == null) {
            top = listNode;
        } else {
            listNode.next = top;
            top = listNode;
        }
    }
    // 出栈操作
    public int pop() {
        if (top == null) {
            throw new RuntimeException("栈空,无法弹出~");
        }
        int data = top.no;
        top = top.next;
        return data;
    }
    // 遍历栈并打印栈中元素
    public void list() {
        ListNode current = top;
        System.out.println("Stack elements: ");
        while (current != null) {
            System.out.println(current.no + " ");
            current = current.next;
        }
        System.out.println();
    }
    
    // 查看栈顶
    public int peek() {
        if (top == null) {
            throw new RuntimeException("Stack is empty");
        }
        return top.no;
    }
}
```

### 前缀\中缀\后缀表达式

#### 前缀表达式(波兰表达式)

1. 前缀表达式又称波兰式, 前缀表达式的运算符位于操作数之前
2. 举例：(3+4)\*5-6 对应的前缀表达式是：-\*+3456

> 前缀表达式的计算机求值
>
> 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例：(3+4)\*5-6 对应的前缀表达式是：-\*+3456，针对前缀表达式求值步骤如下：

1) 从右至左扫描，将6，5，4，3压入堆栈
2) 遇到 + 运算符，因此弹出 3 和 4（3为栈顶元素，4为次顶元素），计算出 3+4 的值，得7，再将7入栈
3) 接下来是 * 运算符，因此弹出 7 和 5，计算出 7*5=35，将35入栈
4) 最后是 - 运算符，计算出 35-6 的值，即29，由此得出最终结果

#### 中缀表达式

1. 中缀表达式就是常见的运算表达式，如 (3+4)\*5-6
2. 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作（前面我们讲的案例就能看得这个问题），因此，在计算结果时，往往会将中缀表达式转换成其他表达式来操作（一般转成后缀表达式）

> 前缀表达式的计算机求值
>
> 从左至右扫描表达式,通过一个index值（索引），来遍历的我们的表达式
>
> 如果是一个数字，就直接入数栈
>
> 如果发现是一个符号
>
> - 如果当前符号栈为空，直接入符号栈栈
> - 如果符号栈有操作符，就进行比较，**如果当前的操作符的优先级小于或者等于栈中的操作符**，就需要从数栈中pop出两个数，在从符号栈中pop一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，**如果当前的操作符的优先级大于栈中的结果**，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
>
> 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并允许最后在数栈中只有一个数字，就是表达式的结果

#### 后缀表达式(逆波兰表达式)

1. 后缀表达式又称逆波兰表达式与前缀表达式相似，只是运算符位于操作数之后
2. 例如：(3+4)\*5-6 对应的后缀表达式就是 3 4 + 5 * 6 -

> 后缀表达式的计算机求值
>
> 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈，重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如：(3+4)\*5-6 对应的后缀表达式就是 3 4 + 5 * 6 -，针对后缀表达式求值步骤如下

1. 从左至右扫描，将 3 和 4 压入堆栈
2. 遇到 + 运算符，因此弹出 4 和 3（4为栈顶元素，3为次顶元素），计算出 3 + 4 的值，得7，再将7压入栈
3. 将5入栈
4. 接下来是 * 运算符，因此弹出 5 和 7，计算出 7*5=35，将35入栈
5. 将6入栈
6. 最后是 - 运算符，计算出 35-6 的值，即29，由此得出最终结果

| 正常表达式      | 逆波兰表达式  |
| :-------------- | ------------- |
| a+b             | a b +         |
| a + (b - c)     | a b c - +     |
| a + (b - c) * d | a b c - d * + |
| a + d * (b - c) | a d b c - * + |
| a = 1 + 3       | a 1 3 + =     |

### 运用实例

#### 综合计算器(中缀)

- 分为两个栈：数栈(numStack)存放数、符号栈(operStack)存放运算符
- 思路
  - 通过一个index值（索引），来遍历的我们的表达式
  - 如果是一个数字，就直接入数栈
  - 如果发现是一个符号
    - 如果当前符号栈为空，直接入符号栈栈
    - 如果符号栈有操作符，就进行比较，**如果当前的操作符的优先级小于或者等于栈中的操作符**，就需要从数栈中pop出两个数，在从符号栈中pop一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，**如果当前的操作符的优先级大于栈中的结果**，入数栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
  - 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并允许
  - 最后在数栈中只有一个数字，就是表达式的结果

```java
public class Calculator {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        String expression = "888+2*6-2";
        int result = calculator.calculate(expression);
        System.out.printf("表达式 %s = %d", expression, result);
    }
    public static int calculate(String expression) {
        // 创建两个栈, 数栈和符号栈
        ArrayStack numStack = new ArrayStack(10);
        ArrayStack operStack = new ArrayStack(10);
        // 用户扫描的索引
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int result = 0;
        char ch = ' '; // 将每次得到的char保存到ch
        // 用于拼接多位数
        String keepNum = "";
        // 开始用while循环的扫描expression
        while (true) {
            // 依次得到expression的每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            // 判断ch是什么, 然后做相应的处理
            // 如果是运算符
            if (operStack.isOper(ch)) {
                // 判断当前的符号栈是否为空
                if (!operStack.isEmpty()) {
                    // 如果当前的操作符的优先级小于或者等于栈中的操作符就需要从数栈中pop出两个数，
                    // 在从符号栈中pop一个符号，进行运算，将得到结果，入数栈，
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())) {
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        result = numStack.cal(num1, num2, oper);
                        // 把运算结构入符号栈
                        numStack.push(result);
                        // 然后将当前的操作符入符号栈,
                        operStack.push(ch);
                    } else {
                        // 如果当前的操作符的优先级大于栈中的结果入数栈，
                        // 然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，
                        // 就直接入符号栈
                        operStack.push(ch);
                    }
                } else { // 如果为空,直接入栈
                    operStack.push(ch);
                }
            } else {
                // 如果是数,则直接入数栈
                //numStack.push(ch - 48); // ch是字符, '1' -> 1
                // 分析思路
                // 1. 当处理多位数时,不能发现是一个数就立即入栈,因为可能是多为数
                // 2. 在处理数时, 需要向expression的表达式的index后再看一位,如果是数就进行扫描,如果是符号才入栈
                // 3. 需要定义一个字符串遍历,用于拼接

                // 处理多位数
                keepNum += ch;

                // 如果ch已经是expession已经是最后一位,直接入栈
                if (index == expression.length() - 1) {
                    numStack.push(ch - 48);
                } else {
                    // 判断下一个字符是不是数字,如果是数字,则进行继续扫描,如果是运算符则入栈
                    char temp = expression.substring(index + 1, index + 2).charAt(0);
                    // 如果后一位是运算符,则入栈
                    if (operStack.isOper(temp)) {
                        numStack.push(Integer.parseInt(keepNum));
                        // 清空keepNum
                        keepNum = "";
                    }
                }
            }
            // 让index + 1, 并判断是否扫描到 expression 最后
            index++;
            if (index >= expression.length()) {
                break;
            }
        }
        // 当表达式扫描到最后时,就顺序的从数栈和符号栈中pop出相应的数和符号,并运行
        while (true) {
            // 如果符号栈为空, 则计算到最后的结果, 数栈中只有一个数字[结果]
            if (operStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            result = numStack.cal(num1, num2, oper);
            numStack.push(result);
        }
        // 将数栈的最后的数pop出来就是最后的结果
        result = numStack.pop();
        return result;
    }
}

// 先创建一个栈

// 定义一个 ArrayStack 表示栈
// 扩展一下功能
class ArrayStack {
    // 栈的大小
    private int maxSize;
    // 数组，模拟栈，数据就放在该数组中
    private int[] stack;
    // top表示栈底，初始化为-1
    private int top = -1;

    // 构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    // 查看栈顶
    public int peek() {
        return stack[top];
    }

    // 栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    // 栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int val) {
        // 先判断栈满
        if (isFull()) {
            System.out.println("栈满，无法放入!");
            return;
        }
        top++;
        stack[top] = val;
    }

    // 出栈, 将栈底的数据返回
    public int pop() {
        // 先判断是否为空
        if (isEmpty()) {
            throw new RuntimeException("栈空，无法弹出!");
        }
        int temp = stack[top];
        top--;
        return temp;
    }

    // 显示栈的情况[遍历栈],遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空，没有数据~");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }

    // 返回运算符的优先级, 优先级是开发者确定, 优先级使用数字表示
    // 数字越大, 优先级越高
    public int priority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '-' || oper == '+') {
            return 0;
        } else {
            return -1; // 表达式只有加减乘除
        }
    }

    // 判断是否是运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    // 计算方法
    public int cal(int num1, int num2, int oper) {
        int result = 0; // 用户存放计算的结果
        switch (oper) {
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num2 - num1; // 注意顺序
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/':
                result = num2 / num1;
                break;
            default:
                break;
        }
        return result;
    }
}
```

#### 逆波兰计算器(后缀)

1. 输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果
2. 支持小括号和多位数整数，只支持对整数的计算
3. 思路分析
   1. 先将表达式放入ArrayList中, 将String转换为ArrayList
   1. 将ArrayList传递给一个方法,配合栈完成计算

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈，重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

```java
public class PolandNotation {
    public static void main(String[] args) {
        // 先定义逆波兰表达式
        // (3+4) * 5 - 6 => 3 4 + 5 * 6 -
        // 逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "3 4 + 5 * 6 -";
        // 思路:3 4 + 5 * 6 -
        // 1. 先将 "3 4 + 5 * 6 -" 放入ArrayList中
        // 2. 将ArrayList传递给一个方法,配合栈完成计算
        List<String> rpnList = getListString(suffixExpression);
        System.out.println("rpnList:" + rpnList);
        // 将表达式传入函数,进行逆波兰表达式运算
        int res = calculate(rpnList);
        System.out.println("计算的结果是:" + res);
    }

    // 将逆波兰表达式依次将数据和运算符放入到ArrayList中
    public static List<String> getListString(String suffixExpression) {
        // 将 suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        for (String s : split) {
            list.add(s);
        }
        return list;
    }

    // 完成对逆波兰表达式的运算 (3+4) * 5 - 6 => 3 4 + 5 * 6 -
    // 1.从左至右扫描，将3和4压入堆栈
    // 2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7压入栈
    // 3.将5入栈
    // 4.接下来是*运算符，因此弹出5和7，计算出7*5=35，将35入栈
    // 5.将6入栈
    // 6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果
    public static BigDecimal calculate(List<String> suffixList) {
		// 创建一个栈,只需要一个栈即可
		Stack<String> stack = new Stack<>();
		for (String item : suffixList) {
			// 这里使用正则表达式取出数
			// 如果匹配的一位或多为数字则入栈
			if (item.matches("\\d+(\\.\\d+)?")) {
				// 入栈
				stack.push(item);
			} else {
				// 遇到运算符时，弹出栈顶的两个数,并进行运算
				// pop出两个数,并运算, 在入栈

				BigDecimal num2 = new BigDecimal(stack.pop());
				BigDecimal num1 = new BigDecimal(stack.pop());
//				double res = 0.0;
				BigDecimal res = new BigDecimal(0);
				if (item.equals("+")) {
//					res.add(num1
					res = num1.add(num2);
				} else if (item.equals("-")) {
					res = num1.subtract(num2);
				} else if (item.equals("*")) {
					res = num1.multiply(num2);
				} else if (item.equals("/")) {
					res = num2.divide(num2);
				} else {
					throw new RuntimeException("运算符有误");
				}
				// 把res入栈
				stack.push(String.valueOf(res));
			}
		}
		// 最后留在stack中的数据就是运算结果
		return new BigDecimal(stack.pop());
	}
}
```

#### 中缀表达式转换后缀表达式

> 中缀转后缀计算：
>
> 1. 初始化两个栈：运算符栈 `s1` 和储存中间结果的栈 `s2`
> 2. 从左至右扫描中缀表达式
> 3. 遇到操作数时，将其压入 `s2`
> 4. 遇到运算符时，比较其与 `s1` 栈顶运算符的优先级
>    1. 如果 `s1` 为空，或栈顶运算符为左括号 `(`，则直接将此运算符入栈
>    2. 否则，若运算符优先级比栈顶运算符的高，也将运算符压入 `s1`
>    3. 否则, 若运算符小于等于栈顶运算符，则将 `s1` 栈顶的运算符弹出并压入到 `s2`，再次转到 `s1` 中与新的栈顶运算符相比较；
>
> 5. 遇到括号时
>    1. 如果是左括号 `(` ，则直接压入 `s1`
>    2. 如果是右括号 `)`，则依次弹出 `s1 ` 栈顶的运算符，并压入 `s2`，直到遇到左括号位置，此时将这一对括号丢弃
> 6. 重复步骤2-5，直到表达式的最右边
> 7. 将 `s1` 剩余的运算符依次弹出并压入 `s2`
> 8. 依次弹出 `s2` 中的元素并输出，结果的逆向即为中缀表达式对应的后缀表达式

将中缀表达式 1+((2+3)*4)-5 转为后缀表达式过程：结果为: 1 2 3 + 4 * + 5 -


| 扫描到的元素 | a（栈底->栈顶）   | b（栈底->栈顶） | 说明                                    |
| ------------ | ----------------- | --------------- | --------------------------------------- |
| 1            | 1                 | 空              | 数字，直接入栈                          |
| +            | 1                 | +               | `a`为空，运算符直接入栈                 |
| (            | 1                 | + (             | 左括号，直接入栈                        |
| (            | 1                 | + ( (           | 左括号，直接入栈                        |
| 2            | 1 2               | + ( (           | 数字，直接入栈                          |
| +            | 1 2               | + ( ( +         | `a`栈顶为(，直接入栈                    |
| 3            | 1 2 3             | + ( ( +         | 数字，直接入栈                          |
| )            | 1 2 3 +           | + (             | 右括号，弹出运算符压入`b`直至遇到左括号 |
| *            | 1 2 3 +           | + ( *           | `a`栈顶为左括号，直接入栈               |
| 4            | 1 2 3 + 4         | + ( *           | 数字，直接入栈                          |
| )            | 1 2 3 + 4 *       | +               | 右括号，弹出运算符压入`b`直至遇到左括号 |
| -            | 1 2 3 + 4 * +     | -               | - 与 + 优先级相等，弹出 +，在压入 -     |
| 5            | 1 2 3 + 4 * + 5   | -               | 数字，直接入栈                          |
| 到达最右端   | 1 2 3 + 4 * + 5 - | 空              | 弹出b剩余的运算符，压入a                |

```java
public static void main(String[] args) {
		// 中缀转换成后缀表达式的功能
        // 说明
        // 1+((2*3)*4)-5 => 转成 1 2 3 + 4 * + 5 -
        // 1. 因为直接对str进行操作,不方便,因此先将字符串转成一个中缀的List
        // 既 "1+((2*3)*4)-5" => ArrayList[1,+,(,(,2,*,3,),*,4,),-,5]
        // 2. 将得到的中缀表达式对应的List => 后缀表达式对应的List
        // 既[1,+,(,(,2,*,3,),*,4,),-,5] => ArrayList[1,2,3,+,4,*,+,5,-]
        String expression = "1+((2+3.3)*4)-15";
		// System.out.println(expression);
		List<String> infixExpressionList = toInfixExpressionList(expression);
		System.out.println("中缀表达式List:" + infixExpressionList);
		List<String> suffixExpressionList = parseSuffixExpressionList(infixExpressionList);
		System.out.println("后缀表达式List:" + suffixExpressionList);
		BigDecimal calculate = calculate(suffixExpressionList);
		System.out.println("计算的结果是:" + calculate);
}
// 将中缀表达式转换成后缀表达式:
public static List<String> parseSuffixExpressionList(List<String> expression) {
    // 定义两个栈
    // 符号栈
    Stack<String> s1 = new Stack<String>();
    // 存储中间结果的栈
    // 因为s2这个栈,在整个转换过程中,没有pop操作,还需要逆序输出
    // 因此比较麻烦,这里我们就不用Stack<String>,直接使用List<String>
    List<String> s2 = new ArrayList<String>();
//1+((2+3)*4)-5
    for (String item : expression) {
        // 如果是数字,则直接压入s2
        if (item.matches("\\d+(\\.\\d+)?")) {
            s2.add(item);
        } else if (item.equals("(") || s1.isEmpty()) {
        // 如果s1为空，或栈顶运算符为左括号(，则直接将此运算符入栈
            s1.push(item);
        } else if (item.equals(")")) {
        // 如果是右括号 `)` ,则依次弹出 s1 栈顶的运算符, 并压入到 s2,直到遇到左括号的位置,此时将这一对括号丢弃
            while (!s1.peek().equals("(")) {
                s2.add(s1.pop());
            }
            s1.pop();
        } else {
        // 否则,若运算符优先级小于等于栈顶运算符,则将 s1 栈顶的运算符弹出并押入到 s2,再次转到 s1中与新的栈顶运算符相比较
            int v1 = Operation.getValue(s1.peek());
            int v2 = Operation.getValue(item);
            while (s1.size() != 0 && v1 >= v2) {
                s2.add(s1.pop());
            }
            s1.push(item);
        }
    }

    // 将s1剩余的元素依次弹出并压入到s2
    while (!s1.isEmpty()) {
        s2.add(s1.pop());
    }

    // 因为存放到List,因此按正常输出就是正常的逆波兰表达式
    return s2;
}


// 将中缀表达式转换成List
public static List<String> toInfixExpressionList(String expression) {
    // 定义一个list, 存放中缀表达式对应的内容
    List<String> list = new ArrayList<String>();
    // 指针,用于遍历expression
    int i = 0;
    // 对多位数的拼接
    String str;
    // 每遍历到一个字符,就放入c
    char c;
    do {
        c = expression.charAt(i);
        if (c == ' ') {
            i++;
        }
        // 如果c是一个非数字, 或者小数点,就需要加入到list中
        else if (c < '0' || c > '9') {
            list.add("" + expression.charAt(i));
            i++;
        } else {
            // 如果是一个数字,需要考虑多位数
            // 先将str为空
            str = "";
            // '0'[48] - '9'[57]
            while (i < expression.length() && (c = expression.charAt(i)) >= '0' && c <= '9' || c == '.') {
                str += c; // 拼接
                i++;
            }
            list.add(str);
        }
    } while (i < expression.length());
    return list;
}
```

## 递归

> 递归就是方法自己调用自己,每次传入不同的参数,有助于解决复杂的问题

递归需要遵守的重要规则

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量时独立的，不会相互影响
3. 如果方法中使用的是引用类型变量，就会共享该引用类型的数据
4.  递归必须向退出递归的条件逼近，否则就是无限递归
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

递归可以解决什么样的问题

1. 各种数学问题：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题
2. 各种算法，例如快排，归并排序，二分查找，分治算法

### 迷宫问题

> 迷宫问题是典型的图的搜索问题。
>
> 假设一个迷宫，只有一个入口和一个出口。如果从迷宫的入口到达出口，途中不出现行进方向错误，则得到一条最佳路线。
>
> 为此，用一个二维数组map来表示迷宫。
> (1)当数组元素map=1，表示该位置是墙壁，不能通行。
>
> (2)当数组元素map=2，表示该位置是通路，可以通行。
>
> (3)当数组元素map=3，表示该位置是思路，无法通过
>
> 注意：数组的上下左右四周必须是迷宫的墙，

- 回溯法
  - 定义：回溯法(backtracking)是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。

设任一时刻在迷宫中的位置[i][j]标记为X，X周围有8个前进方向，它实际是一系列交通路口，如果某一方向是2值，表示该方向有路可通，如果某一方向为0值，表示该方向没有走过，反之表示该方向已堵死

为了有效选择方向，可以定义一个寻找策略，例如，【下，右，上，左】，根据这个策略逐个前进

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404250907033.png)

如图，小球从起点(1,1)需要移动到终点(6,5)，求是否可以顺利达到终点，标识路径为2

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404250908497.png)

下图即为采用 下->右->上->左的策略得出的结果。

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404250908745.png)

```java
public class Labyrinth {
    public static void main(String[] args) {
        // 创建地图，8行7列
        int[][] map = new int[8][7];

        // 初始化地图边界和障碍物
        initializeMap(map);

        // 打印初始地图
        printMap(map);

        // 使用递归回溯找路
        if (findPath(map, 1, 1)) {
            System.out.println("找到通路！");
        } else {
            System.out.println("未找到通路！");
        }

        // 打印走过的地图
        System.out.println("走过的地图：");
        printMap(map);
    }

    // 初始化地图边界和障碍物
    public static void initializeMap(int[][] map) {
        // 使用1表示墙
        // 设置上下的墙为1
        for (int i = 0; i < map[0].length; i++) {
            map[0][i] = 1;
            map[map.length - 1][i] = 1;
        }

        // 设置左右的墙为1
        for (int i = 0; i < map.length; i++) {
            map[i][0] = 1;
            map[i][map[0].length - 1] = 1;
        }

        // 随机放置障碍物
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[0].length; j++) {
                // 20% 的概率放置障碍物, 并且，第一行，第一列不可以放置障碍物
                if (random.nextDouble() < 0.2 && (i != 1 || j != 1)
						&& (i != map.length - 2 || j != map[0].length - 2)) { 
                    map[i][j] = 1;
                }
            }
        }
    }

    // 打印地图
    public static void printMap(int[][] map) {
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[0].length; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }

    // 使用递归回溯找路
    public static boolean findPath(int[][] map, int i, int j) {
        if (map[map.length - 2][map[0].length - 2] == 2) {
            return true; // 通路已找到
        } else {
            if (map[i][j] == 0) {
                map[i][j] = 2; // 假定该点可以走通

                // 下->右->上->左 走
                if (findPath(map, i + 1, j) || findPath(map, i, j + 1)
                        || findPath(map, i - 1, j) || findPath(map, i, j - 1)) {
                    return true;
                } else {
                    map[i][j] = 3; // 走不通，标记为死路
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
```

### 八皇后

> 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出:在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，
>
> 即:任意两个皇后都不能处于同一行、同一列或同一斜线上,问有多少种摆法。(92种解法)

![image-20240425092646602](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404250926987.png)

1. 思路分析
   1. 第一个皇后先放在第一行第一列
   2. 第二个皇后放在第二行第一列，然后判断是否OK，如果不OK，继续放在第二列，第三列、依次把所有列都放完，找到一个合适的
   3. 继续第三个皇后，还是第一列，第二列...直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
   4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到
   5. 然后回头继续第一个皇后放第二列，继续执行【1，2，3，4】步骤

实际上可以使用一个一维数组来存放解法,第n个元素就是第几行

```java
public class Queue8 {
    // 定义一个max表示共有多少个皇后
    int max = 8;
    // 定义数组array,保存皇后放置结果
    int[] array = new int[max];
    // 总计解法
    static int count = 0;
    // 总计查找次数
    static int judgeCount = 0;

    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.printf("一共有%d种解法：", count);
        System.out.printf("一共有%d种冲突次数：", judgeCount);
    }

    // 编写一个方法，放置第n个皇后
    // 特别注意：check是每一次递归的时候，进入到check中，都一次for循环，因此会有回溯
    private void check(int n) {
        // 如果n=8，其实8个皇后就已经放好了
        if (n == max) {
            print();
            return;
        }
        // 依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            //先把当前的这个皇后n，放到该行的第1列
            array[n] = i;
            // 判断当放置第n个皇后到i列时，是否冲突
            // 如果不冲突，接着放n+1个皇后
            if (judge(n)) {
                // 接着放n+1个皇后，开始递归
                check(n + 1);
            }
            // 如果冲突，就继续执行 array[n] = i; 下一次循环
            // 即将第n个皇后，放置在本行的后一个位置
        }
    }

    /**
     * 查看当我们摆放第n个皇后时,就去检测该皇后是否和前面摆放的皇后冲突
     * n表示第n个皇后
     *
     * @param n
     * @return
     */
    private boolean judge(int n) {
        judgeCount++;

        for (int i = 0; i < n; i++) {
            // 1. array[i] == array[n] 判断第n个皇后是否和前面的n-1个皇后在同一列
            // 2. Math.abs(n - i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i个皇后在同一斜线
            // n = 1, i=0时候, 则代表第二个皇后,放在第2列,值为1
            // n = 1 的时候,第二列也是1,也就是array[1] = 1
            // Math.abs(n - i) == Math.abs(array[n] - array[i])
            // Math.abs(1-0)=1 == Math.abs(1-0)=1
            // 相等就是在一个斜线上
            // 3. 判断是否在同一行，没有必要，n每次都在递增
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }

    // 打印皇后摆放的位置
    private void print() {
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```

## 排序

> 排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程
>
> 排序的分类
>
> - 内部排序
>
> 指将需要处理的所有数据都加载到内部存储器中进行排序
>
> - 外部排序法
>
> 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序

常见的排序算法

- 内部排序（使用内存）
  - 插入排序
    - 直接插入排序
    - 希尔排序
  - 选择排序
    - 简单选择排序
    - 堆排序
  - 交换排序
    - 冒泡排序
    - 快速排序
  - 归并排序
  - 基数排序
- 外部排序（内存和外存结合）

### 时间/空间复杂度

#### 算法时间复杂度

1. 事后统计法

这种方法可行,但是有两个问题:一是要想对设计的算法的运行性能进行评测，需要实际运行该程序;二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。

2. 事前估算的方法

通过分析某个算法的事件复杂度来判断那个算法更优

##### 时间频度

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

```java
int total = 0;
int end = 100;
for(int i = 1; i<= end; i++){
    total += i;
}

T(n) = n+1;
// 直接计算
total = (1+end)*end/2;
T(n)=1
```

- **常数项可以忽略**

2n+20 和 2n 随着n变大，执行结果无限接近，所以常数可以忽略

|      | `T(n)=2n+20` | `T(n)=2*n` |
| ---- | ---------- | -------- |
| 1    | 22         | 2        |
| 2    | 24         | 4        |
| 4    | 30         | 10       |
| 8    | 36         | 16       |
| 15   | 50         | 30       |
| 30   | 80         | 60       |
| 100  | 220        | 200      |
| 300  | 620        | 600      |

- **忽略低次项**

表达式中，随着n的逐渐变大，执行结果无限接近，所以可以忽略低次项

|      | `T(n)=2N^2+3n+1` | `T(2n^2)` | `T(n^2+5n+2n)` | `T(n^2)` |
| ---- | ---------------- | --------- | -------------- | -------- |
| 1    | 15               | 2         | 26             | 1        |
| 2    | 24               | 8         | 34             | 4        |
| 5    | 75               | 50        | 70             | 25       |
| 8    | 162              | 128       | 124            | 64       |
| 15   | 505              | 450       | 320            | 225      |
| 30   | 1900             | 1800      | 1070           | 900      |
| 100  | 20310            | 20000     | 10520          | 10000    |

- **忽略系数**

随着n值变大,表达式的执行结果逐渐重合,说明系数可以忽略

|      | T(3n^2+2n) | T(5n^2+7n) |
| ---- | ---------- | ---------- |
| 1    | 5          | 12         |
| 2    | 16         | 34         |
| 5    | 85         | 160        |
| 8    | 208        | 376        |
| 15   | 705        | 1230       |
| 30   | 2760       | 4710       |
| 100  | 30200      | 50700      |

##### 时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

2. T(n)不同，但时间复杂度可能相同。如:T(n)=n^2+7n+6与T(n)=3n^2+2n+2, 它们的T(n)不同，但时间复杂度相同，都为O(n^2)。

3. 计算时间复杂度的方法

   使用常数1代替运行时间中的所有加法常数

   修改后的运行次数函数中,只保留最高阶项

   去除最高阶项的系数

###### 常见的时间复杂度

- 常数阶O(1)
- 对数阶O(log<sub>2</sub>n)
- 线性阶O(n)
- 线性对数阶O(nlog<sub>2</sub>n)
- 平方阶O(n^2)
- 立方阶O(n^3)
- k次方阶O(n^4)
- 指数阶O(2^n)

常见的算法时间复杂度由小到大依次为:`O(1)` < `O(log`<sub>2</sub>`n) `< `O(n)  ` < `O(nlog`<sub>2</sub>`n)` < `O(n^2)` < `O(n^3)` < `O(n^k)` < `O(2^n)` < `O(n!)`，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

- 对数阶O(log<sub>2</sub>n)

说明:在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x次之后，i就大于2了，此时这个循环就退出了，也就是说2的x次方等于n，那么x=log<sub>2</sub>n也就是说当循环log<sub>2</sub>n次以后，这个代码就结束了。因此这个代码的时间复杂度为:O(log<sub>2</sub>n)。O(log<sub>2</sub>n)的这个2时间上是根据代码变化的，i=i*3，则是O(log<sub>3</sub>n).

```java
int i = 1;
while(i < n){
    i = i * 2;
}
```

- 线性对数阶O(nlog<sub>2</sub>n)

就是将时间复杂度为O(logn)的代码循环N遍,时间复杂度就是O(nlogn)

```java
for(m=1; m<=n; m++){
    i = 1;
    while(i <= n){
        i = i * 2;
    }
}
```

###### 平均/最坏时间复杂度

| 排序法 | 平均时间             | 最差情形             | 稳定度 | 额外空间 | 备注                              |
| :----- | :------------------- | :------------------- | :----- | :------- | :-------------------------------- |
| 冒泡   | O(n^2)               | O(n^2)               | 稳定   | O(1)     | n小时较好                         |
| 交换   | O(n^2)               | O(n^2)               | 不稳定 | O(1)     | n小时较好                         |
| 选择   | O(n^2)               | O(n^2)               | 不稳定 | O(1)     | n小时较好                         |
| 插入   | O(n^2)               | O(n^2)               | 稳定   | O(1)     | 大部分已排序时较好                |
| 基数   | O(nlog<sub>R</sub>B) | O(nlog<sub>R</sub>B) | 稳定   | O(n)     | B是真数(0-9)<br />R是基数(个十百) |
| Shell  | O(nlogn)             | O(n^s)               | 不稳定 | O(1)     | s是所选分组                       |
| 快速   | O(nlogn)             | n(n^2)               | 不稳定 | O(nlogn) | n大时较好                         |
| 归并   | O(nlogn)             | O(nlogn)             | 稳定   | O(1)     | n大时较好                         |
| 堆     | O(nlogn)             | O(nlogn)             | 不稳定 | O(1)     | n大时较好                         |

#### 算法空间复杂度

类似于时间复杂度的过论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大
小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增天，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况

在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

### 冒泡排序

> 冒泡排序(Bubble Sorting)的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底的气泡一样逐渐向上冒泡
>
> 时间复杂度:O(n^2)

![动图](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404281714118.webp)

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404301518065.webp)

```java
public static void buffle_sort(int[] arr) {
    int temp; //临时变量
    boolean flag = false; // 标识变量,表示是否进行过交换
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            // 如果前面的数字比后面的大,则进行交换
            if (arr[j] > arr[j + 1]) {
                flag = true;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        // 在一次排序中,一次交换都没有发生过,那么就代表整个数组已经排好序了,不需要在进行下次排序了,直接结束
        if(!flag){
            break;
        }
        // 重置flag,进行下次判断
        flag = false;
        // System.out.println("第" + (i+1) + "轮插入: " + Arrays.toString(arr));
    }
}
```

事后统计法

```java
public static void main(String[] args) {
    int arr[] = new int[80000];

    for (int i = 0; i < 80000; i++) {
        arr[i] = (int) (Math.random() * 80000);
    }

    Date date1 = new Date();
    SimpleDateFormat simpleDateFormat = 
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    String data1Str = simpleDateFormat.format(date1);
    System.out.println("排序前: " + data1Str);

    buffle_sort(arr);

    Date date2 = new Date();
    String data2Str = simpleDateFormat.format(date2);
    System.out.println("排序前: " + data2Str);
}
```

### 选择排序

> 选择排序也输入内部排序法,是从要排序的数据中,按指定的规则选出某一元素,再依规定交换位置后达到排序的目的
>
> 第一次从arr[0]~arr[n-1]中选取最小值,与arr[0]交换
>
> 第二次从arr[1]~arr[n-1]中选取最小值,与arr[1]交换
>
> 第三次从arr[2]~arr[n-1]中选取最小值,与arr[2]交换
>
> 第i次从arr[i-1]~arr[n-1]中选取最小值,与arr[i-1]交换
>
> 第n-1次从arr[n-2]~arr[n-1]中选取最小值,与arr[n-2]交换
>
> 总共通过n-1次,得到一个按排序码从小到大排列的有序序列

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404301512419.gif)

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404301513501.webp)

```java
// 选择排序
public static void selectSort(int[] arr) {
    // 遍历数组
    for (int i = 0; i < arr.length - 1; i++) {
        // 初始化最小值的索引和最小值
        int minIndex = i;
        int min = arr[i];
        // 找出最小值
        for (int j = i + 1; j < arr.length; j++) {
            if (min > arr[j]) {
                // 更新最小值和最小值的索引
                min = arr[j];
                minIndex = j;
            }
        }
        // 将最小值交换到当前位置
        if (minIndex != i) {
            arr[minIndex] = arr[i];
            arr[i] = min;
        }
        // System.out.println("第" + (i+1) + "轮插入: " + Arrays.toString(arr));
    }
}
```

然后进行事后统计法进行测算一下,比冒泡排序时间缩短了很多

### 插入排序

> 插入排序属于内部排序法,是对于要排序的元素以插入的方式找寻该元素的适当位置,以达到排序的目的
>
> 把n个待排序的元素看成为一个有序表和一个无序表,开始时有序表只包含一个元素,无序表中包含有n-1个元素,排序过程中每次从无序表中取出第一个元素,把它的排序码依次与有序表元素的排序码进行比较,将它插入到有序表中的适当位置,使之成为新的有序表

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404301559663.webp)

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202404301655396.webp)

```java
//插入排序
public static void insertSort(int[] arr) {
    // 使用逐步推导
    for (int i = 1; i < arr.length; i++) {
        // 定义待插入的数, 从第二个位置开始
        int insertValue = arr[i];
        // 定义待插入数前面一个数的索引
        int insertIndex = i - 1;
        // 给insertValue找到插入的位置
        // 1. 保证不越界
        // 2. 待插入的值,还没有找到待插入的位置
        // 3. 就需要将arr[insertIndex]后移
        while (insertIndex >= 0 && insertValue < arr[insertIndex]) {
            arr[insertIndex + 1] = arr[insertIndex];
            insertIndex--;
        }
        // 当退出while循环时,说明插入的位置找到, insertIndex+1
        // 判断是否需要赋值
        if (insertValue + 1 != i) {
            arr[insertIndex + 1] = insertValue;
        }
        // System.out.println("第" + i + "轮插入: " + Arrays.toString(arr));
    }
}
```

### 希尔排序

> 希尔排序，经过简单插入排序改进后一个更高效的版本，也称为缩小增量排序
>
> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法被终止

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202405071459646.gif)

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202405071459898.webp)

- 交换法

```java
// 交换法
public static void shellSort(int[] arr) {
    int temp = 0;
    // 增量gap，并逐步的缩小增量
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        // 第一轮， 将十个数据分成gap组
        for (int i = gap; i < arr.length; i++) {
            // 遍历各组中所有的元素（共gap组，每组有gap/2个元素），步长为gap
            for (int j = i - gap; j >= 0; j -= gap) {
                // 如果当前元素大于加上步长后的那个元素，说明交换
                if (arr[j] > arr[j + gap]) {
                    temp = arr[j];
                    arr[j] = arr[j + gap];
                    arr[j + gap] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

- 移位法

```java
// 移位法
public static void shellSort(int[] arr) {
    int temp = 0;
    // 增量gap，并逐步的缩小增量
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        //从gap元素开始，逐个对其所在的组进行直接插入排序
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            // 保存当前位置的元素值
            temp = arr[j];
            // 如果当前元素小于同组中的前一个元素，则向前移动并插入
            if (arr[j] < arr[j - gap]) {
                while (j - gap >= 0 && temp < arr[j - gap]) {
                    // 移动
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                // 当退出之后，就给temp找到插入的位置
                arr[j] = temp;
            }
        }
    }
}
```

### 快速排序

> 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

1. 首先设定一个分界值（pivot）：通过该分界值将数组分成左右两部分（partition）。
2. Compare and Swap：将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 
3. Recursive：然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202405090845924.gif)

![img](https://gcore.jsdelivr.net/gh/Luckiiest/noteImage@master/202405090848306.png)







































































